

function pr(debug, ...)
    if debug then
        printf("Repackable Medpacks: %s",...)
    end
end

------------------
-- Imports
------------------

-- Functions

get_string = game.translate_string
sum = rpmk_utils.sum
concat_pairs = rpmk_utils.concat_pairs
concat = rpmk_utils.concat
index_of = rpmk_utils.index_of
lower = string.lower
collect_section = utils_data.collect_section

-- Configs

ini_medpack = ini_file_ex("items\\items\\items_repackable_medpack.ltx")
ini_medical = ini_file_ex("items\\items\\items_medical.ltx")
ini_drugs = ini_file_ex("items\\items\\items_drugs.ltx")
ini_drink = ini_file_ex("items\\items\\items_drink.ltx")
ini_manager = ini_file_ex("items\\settings\\itms_manager.ltx")

-- Other

bullet_point = get_string("st_medpack_descr_bullet_point")

-- Globals & Constants
MEDPACK_TABLE = {}

function get_colour_string(name)
    return strformat("%c[%s]", name)
end

-- Once a medpack enters the player's inv add to table
-- Store section, id, package contents, capacity, each item weight + medpack weight, max weight threshold
-- if unpacking decrease only package contents
-- if repack add to package contents and for each item added also add it's weight
-- above max weight threshold and medpack slowly starts to decrease in condition (possible update icon in stages)
-- if medpack is open, when zipped, create closed medpack with package contents, remove open medpack
-- if medpack is closed, when unzipped, create open medpack with package contents, remove closed medpack
-- if sold remove from table
-- if dropped and player moves more than 100m from it remove from table
-- if dropped and trans level then remove  
-- id = medpack id
-- section = medpack section name
-- contents = list of medical items
-- capacity = current total amount of items in medpack
-- total_weight = the sum weight of all items in the medpack plus the medpack weight
-- max_weight = total weight limit that the medpack can contain
-- Remove all kits of medpacks and replace all trader profiles with medpack with repackable version








-------------------------------
-- Tables
-------------------------------

zip_colour = {
    ["zipped"] = get_colour_string("d_green"),
    ["unzipped"] = get_colour_string("d_red")
}

closed_to_zip_status = {
    [true] = "zipped",
    [false] = "unzipped"
}

sect_to_exclude = {
    ["identity_immunities"] = true,
    ["booster"] = true,
    ["medkit_ai1"] = true,
    ["medkit_ai2"] = true,
    ["medkit_ai3"] = true,
    ["booster_multi"] = true,

}

-------------------------------
-- Table Functions
-------------------------------

function vanilla_to_repackable(sect, closed)
    local closed_sects = {
        ["medkit_ai1"] = "medpack_closed_basic",
        ["medkit_ai2"] = "medpack_closed_army",
        ["medkit_ai3"] = "medpack_closed_sci"
    }
    local open_sects = {
        ["medkit_ai1"] = "medpack_open_basic",
        ["medkit_ai2"] = "medpack_open_army",
        ["medkit_ai3"] = "medpack_open_sci"
    }
    if closed then
        return closed_sects[sect]
    end
    return open_sects[sect]
end

function switch_status(sect)
    local medpack_sect = {
        ["medpack_closed_basic"] = "medpack_open_basic",
        ["medpack_closed_army"] = "medpack_open_army",
        ["medpack_closed_sci"] = "medpack_open_sci",
        ["medpack_open_basic"] = "medpack_closed_basic",
        ["medpack_open_army"] = "medpack_closed_army",
        ["medpack_open_sci"] = "medpack_closed_sci"
    }
    return medpack_sect[sect]
end

-------------------------------
-- Bools
-------------------------------

function is_vanilla_medpack(obj)
    local v_m_sects = {
        ["medkit_ai1"] = true,
        ["medkit_ai2"] = true,
        ["medkit_ai3"] = true
    }
    return v_m_sects[obj:section()]
end

function is_repackable_medpack(obj)
    local mp_sects = {
        ["medpack_open_basic"] = true,
        ["medpack_open_army"] = true,
        ["medpack_open_sci"] = true,

        ["medpack_closed_basic"] = true,
        ["medpack_closed_army"] = true,
        ["medpack_closed_sci"] = true
    }
    return mp_sects[obj:section()]
end

function is_medpack_compatible(itm_sect)
    if ini_drugs:section_exist(itm_sect) or ini_medical:section_exist(itm_sect) or ini_drink:section_exist(itm_sect) then
        return true
    end
    return false
end

function is_medpack_open(medpack)
    return not get_closed_status(medpack:id())
end

function is_medpack_closed(medpack)
    return get_closed_status(medpack:id())
end

function is_medpack_useable(medpack)
    local condition = medpack:condition()
    if condition > 39 then
        return true
    end
    return false
end



function is_medpack_empty(medpack)
    local capacity = get_total_itms(medpack:id())
    if capacity > 0 then
        return false
    end
    return true
end

function is_medpack_full(medpack)
    local tw = get_total_weight(medpack:id())
    local mw = get_max_weight(medpack:id())
    pr(true, strformat("total weight: %s type %s max weight: %s type %s", tw, type(tw),mw, type(mw) ))
    return tw >= mw
end

-------------------------------
-- Track medpacks through table
-------------------------------

function mt_new_entry(medpack)
    local _id = medpack:id()
    if is_medpack_in_table(_id) then return end
    local sect = medpack:section()
    local _contents =  default_contents(sect)
    local ti = sum(_contents)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(_id, _contents, bw)
    local mw = default_max_weight(sect)
    
    MEDPACK_TABLE[#MEDPACK_TABLE + 1] = {id=_id, section=sect, contents=_contents, total_itms=ti, total_weight=tw, max_weight=mw, base_weight=bw, closed=true}
    pr(true, strformat("new entry: id=%s section=%s, contents=%s, total items=%s, max capcity=%s, total weight=%s, base weight=%s, closed=%s", _id, sect, _contents, ti, tw, mw, bw, true))
end

function get_entry_index(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr(true, strformat("found entry at %s", idx))
            return idx
        end
    end
end

function mt_remove_entry(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr(true, strformat("removing entry at %s", id))
            MEDPACK_TABLE[idx] = nil
        end
    end
end

function mt_replace_entry(old_id, new_id, sect, _contents, _closed)
    local ti = sum(_contents)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(new_id, _contents, bw)
    local mw = default_max_weight(sect)
    local idx = get_entry_index(old_id) or #MEDPACK_TABLE + 1
    pr(true, strformat("replacing entry at %s: id=%s section=%s, contents=%s, total items=%s, total weight=%s, max weight=%s, base weight=%s, closed=%s", idx, new_id, sect, _contents, ti, tw, mw, bw, true))
    MEDPACK_TABLE[idx] = {id=new_id, section=sect, contents=_contents, total_itms=ti, total_weight=tw, max_weight=mw, base_weight=bw, closed=_closed}
end

function mt_set_var(id, var, value)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] and entry[var] and type(var) == "string" then
            entry[var] = value
        end
    end
end

function mt_get_var(id, var)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return entry[var]
        end
    end
end

function mt_update_vars(id, tbl)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            for k, v in pairs(entry) do
                if tbl[k] then
                    entry[k] = tbl[k]
                end
            end
        end
    end
end

function mt_all_vars(id, unpck)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            if not unpck then
                return entry
            end
            return unpack(entry)
        end
    end
end

function is_medpack_in_table(id)
    for _, entry in pairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return true
        end
    end
    return false
end

-- Getters and Setters for medpack variables: "contents, capacity, total_weight, max_weight"

-------------------------------
-- Getters
-------------------------------
function get_section(id)
    return mt_get_var(id, "section")
end

function get_contents(id)
    return mt_get_var(id, "contents")
end

function get_total_itms(id)
    return mt_get_var(id, "total_itms")
end

function get_total_weight(id)
    return mt_get_var(id, "total_weight")
end

function get_max_weight(id)
    return mt_get_var(id, "max_weight")
end

function get_base_weight(id)
    return mt_get_var(id, "base_weight")
end

function get_closed_status(id)
    return mt_get_var(id, "closed")
end

-------------------------------
-- Setters
-------------------------------

function set_contents(id, contents)
    mt_set_var(id, "contents", contents)
end

function set_total_itms(id, total_itms)
    mt_set_var(id, "total_itms", total_itms)
end

function set_total_weight(id, total_weight)
    mt_set_var(id, "total_weight", total_weight)
end

-------------------------------
-- Default Medpack vars
-------------------------------

function default_max_weight(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_float_ex(sect, "max_weight")
end

function default_contents(sect)
    pr(true, strformat("Getting contents for: %s", sect))
    return build_contents(parse_list(ini_manager, "package_content", sect))
end

function default_base_weight(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_float_ex(sect, "inv_weight")
end

-------------------------------
-- Common Medpack Functions
-------------------------------

function create_new_medpack(obj, closed)
    if is_vanilla_medpack(obj) and not is_medpack_in_table(obj:id()) then
        local contents = default_contents(obj:section())
        local sect = obj:section()
        local repack_sect = vanilla_to_repackable(obj:section(), closed)
        alife():release(alife_object(obj:id()), true)
        local medpack = alife_create_item(repack_sect, db.actor)
        --alife_release(obj)
        pr(true, strformat("Creating %s , with the contents: %s", repack_sect, concat_pairs(contents)))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed)
    end
end

function switch_medpack(obj, closed)
    if is_repackable_medpack(obj) and is_medpack_in_table(obj:id()) then
        local contents = get_contents(obj:id())
        local sect = obj:section()
        local repack_sect = switch_status(sect)
        local medpack = alife_create_item(repack_sect, db.actor)
        --alife_release(obj)
        alife():release(alife_object(obj:id()), true)
        pr(true, strformat("Switching medpack from %s to %s, with the contents: %s", sect, repack_sect, concat_pairs(contents)))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed)
    end
end

-- Medpack Creation & Var building

base_use_package = itms_manager.use_package
function itms_manager.use_package(obj)
    base_use_package(obj)
    create_new_medpack(obj, false)
end

base_use_package_random = itms_manager.use_package_random
function itms_manager.use_package_random(obj)
    base_use_package_random(obj)
    create_new_medpack(obj, false)
end

function build_contents(contents)
    local ordered_contents = {}
 
    for _, item in ipairs(contents) do
        if ordered_contents[item] then
            ordered_contents[item] = ordered_contents[item] + 1
        else
            ordered_contents[item] = 1
        end
    end
    return ordered_contents
end

function get_medpack_comptible_items()
    local items_sects = {}
    
    pr(true, strformat("med items sections: %s", concat(items_sects)))
    local compatible_itms = {}
    local function search(temp, obj)
        pr(true, strformat("Is %s a medpack compatible item?", obj:section()))
        if is_medpack_compatible(obj:section()) and not sect_to_exclude[obj:section()] then
            items_sects[#items_sects + 1] = obj:section()
            compatible_itms[#compatible_itms + 1] = obj
        end
    end

    db.actor:iterate_inventory(search, nil)
    return compatible_itms, items_sects
end

-- Colour Related

function get_colour(name)
    return utils_xml.get_color(name)
end

-- Medpack Description 

base_obj_desc = ui_item.get_obj_desc
function ui_item.get_obj_desc(obj)
    if is_repackable_medpack(obj) then
        pr(true, strformat("updating description for: %s", obj:section()))
        return medpack_descr(obj, obj:section())
    end
end

function medpack_descr(obj, sect)
    if not is_repackable_medpack(obj) then return end
    local descr = ""
    local default_clr = get_colour_string("default")
    local blue_clr = get_colour_string("d_blue")
    local title_grey_clr = get_colour_string("ui_gray_3")
    local text_grey_clr = get_colour_string("ui_gray_2")
    local cyan_clr = get_colour_string("d_cyan")

    local total_items = get_total_itms(obj:id())
    local contents = get_contents(obj:id())

    local function build_string()
        local base_descr = get_string("st_"..sect.."_base_descr")
        local contents_str = title_grey_clr.."CONTENTS:\\n"
        local props_str = title_grey_clr.."PROPERTIES:\\n"
        local storage_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_storage_descr").."\\n"
        local repack_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_repack_descr").."\\n"
        local closed_status = get_closed_status(obj:id())
        local zip_status = closed_to_zip_status[closed_status]
        local zip_status_str = zip_colour[zip_status].." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_"..zip_status.."_descr").."\\n"
        local end_char = "\\n"

        local items_str = ""
        local itr = 1
        for item, amount in pairs(contents) do
            if itr == total_items then
                end_char = "\\n \\n"
            end   
            for i=1, amount do
                     
                items_str = items_str..strformat("%s %s %s %s %s", cyan_clr, bullet_point, default_clr, med_itm_name(item), end_char)
            end
            itr = itr + 1
        end
        if #items_str <= 0 then
            items_str = "\\n"
        end
        return base_descr..contents_str..items_str..props_str..storage_str..repack_str..zip_status_str
    end
    return build_string()
end    

-- Medpack Info

function med_itm_name(sect)
    if ini_drugs:section_exist(sect) then
        return get_string(ini_drugs:r_value(sect, "inv_name"))
    elseif ini_medical:section_exist(sect) then
        return get_string(ini_medical:r_value(sect, "inv_name"))
    elseif ini_drink:section_exist(sect) then
        return get_string(ini_drink:r_value(sect, "inv_name"))
    end  
end

function update_contents(id, new_contents)
    local contents = get_contents(id)
    for item, amount in pairs(new_contents) do
        local cond, value = rpmk_utils.contains(contents, item)
        if cond then
                contents[item] = value + amount
        else
            contents[item] = amount
        end
    end
    set_contents(id, contents)
    set_total_itms(id, sum(contents))
    set_total_weight(id, calculate_total_weight(id, contents, get_base_weight(id)))
    pr(true, strformat("Updating medpack %s, contents %s", id, concat_pairs(contents)))
end

function calculate_total_weight(id, contents, base_weight)
    if #contents <= 0 then return base_weight end    
    local total_weight = get_total_weight(id) or (base_weight or 0.15)
    for item, amount in pairs(contents) do
        for i=1, amount do
            local itm_weight = ini_drugs:r_float_ex(item, "inv_weight") or ini_medical:r_float_ex(item, "inv_weight") or ini_drink:r_float_ex(item, "inv_weight")
            total_weight = total_weight + itm_weight
        end
    end
    pr(false, strformat("total weight: %s", total_weight))
    return round_idp(total_weight, 2)
end
  
function get_medpack_type(id)
    local section = get_section(id)
    for _, pattern in pairs({"(medpack_closed_)", "(medpack_open_)"}) do
        if string.match(section, pattern) then
            local start, _end = string.find(section, pattern)
            return string.sub(section, _end + 1, #section)
        end
    end
end

-- Medpack Functionality

function unpack_all(obj)
    if is_medpack_empty(obj) then
        rpmk_utils.display_msg("st_empty_medpack", nil, get_medpack_type(obj:id()))
        return 
    end
    local contents = get_contents(obj:id())
    for item, amount in pairs(contents) do
        for i=1, amount do
            alife_create_item(item, db.actor)
            rpmk_utils.display_msg("st_unpacked_item", lower(med_itm_name(item)), get_medpack_type(obj:id()))
        end
        contents[index_of(contents, item, true)] = nil
    end
    update_contents(obj:id(), build_contents(contents))
end

function repack_all(obj)
    if is_medpack_full(obj) then
        rpmk_utils.display_msg("st_full_medpack", nil, get_medpack_type(obj:id()))
        return 
    end
    local med_items, med_sects = get_medpack_comptible_items()
    for idx, item in ipairs(med_items) do
        alife_release(item)
        rpmk_utils.display_msg("st_repacked_item", lower(med_itm_name(item:section())), get_medpack_type(obj:id()))
    end
    update_contents(obj:id(), build_contents(med_sects))
end



---------------------------------------
-- Custom Functors
---------------------------------------

-- Unpack

function unpack_condition_met(obj)
    if obj and is_medpack_closed(obj) and not is_medpack_empty(obj) then
        return true
    end
    return false
end

function unpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unpack_condition_met(obj)
end

function unpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unpack")
end

function unpack_action(obj, bag, mode)
    local medpack = obj and is_repackable_medpack(obj)
    if not medpack then return end

    --rpmk_gui.display_medpack_gui(true, nil, medpack)
    unpack_all(obj)
    switch_medpack(obj, false)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_unpack", unpack_condition_function, unpack_menu_function, nil, unpack_action)

-- Fill 

function repack_medpack_condition_met(obj)
    if obj and is_medpack_open(obj) and not is_medpack_full(obj) then
        return true
    end
    return false
end

function repack_medpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return repack_medpack_condition_met(obj)
end

function repack_medpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_repack")
end

function repack_medpack_action(obj, bag, mode)
    local medpack = obj and is_repackable_medpack(obj)
    if not medpack then return end

    --rpmk_gui.display_medpack_gui(nil, true, medpack)
    repack_all(obj)
    switch_medpack(obj, true)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_repack", repack_medpack_condition_function, repack_medpack_menu_function, nil, repack_medpack_action)


-- Zip

function zip_condition_met(obj)
    if obj and is_medpack_open(obj) and is_medpack_useable(obj) then
        return true
    end
    return false
end

function zip_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return zip_condition_met(obj)
end

function zip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_zip")
end

function zip_action(obj, bag, mode)
    local medpack = obj and is_repackable_medpack(obj)
    if not medpack then return end

    local contents = get_contents(medpack:id())
    local closed_sect = switch_status(medpack:sect())
    local obj = alife_create_item(closed_sect, db.actor)
    mt_replace_entry(medpack:id(), obj.id, closed_sect, contents, false)
    alife_release(medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_zip", zip_condition_function, zip_menu_function, nil, zip_action)


-- Unzip

function unzip_condition_met(obj)
    if obj and is_medpack_closed(obj) and is_medpack_useable(obj) then
        return true
    end
    return false
end

function unzip_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unzip_condition_met(obj)
end

function unzip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unzip")
end

function unzip_action(obj, bag, mode)
    local medpack = obj and is_repackable_medpack(obj)
    if not medpack then return end

    local contents = get_contents(medpack:id())
    local open_sect = switch_status(medpack:sect())
    local obj = alife_create_item(open_sect, db.actor)
    mt_replace_entry(medpack:id(), obj.id, open_sect, contents, false)
    alife_release(medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_unzip", unzip_condition_function, unzip_menu_function, nil, unzip_action)


-------------------------------
-- Drag/Drop repack
-------------------------------

function on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
    local p_1, p_2 = obj_1:parent(), obj_2:parent()

    if not ((p_1 and p_1:id() == AC_ID) and (p_2 and p_2:id() == AC_ID)) then
        return
    end

    local itm = obj_1 
    local medpack = obj_2

    if not is_medpack_compatible(itm:section()) or not is_medpack_open(medpack) then return end

    if not drop_condition_met(itm, medpack) then return end

    update_contents(medpack:id(), {itm:section()})
    alife_release(itm)
end

-------------------------------
-- Callbacks
-------------------------------

local function save_table(mdata)
    local SAVE_TABLE = {}
    copy_table(SAVE_TABLE, MEDPACK_TABLE)
    mdata.active_medpacks = SAVE_TABLE
end

local function load_table(mdata)
    local SAVE_TABLE = mdata.active_medpacks or {}
    copy_table(MEDPACK_TABLE, SAVE_TABLE)
end

local function actor_on_item_take(item)
    pr(true, "on take")
    local function search(temp, obj)
        pr(false, strformat("is %s a medpack?", obj:section()))
        create_new_medpack(obj, true)
        
    end

    db.actor:iterate_inventory(search, nil)
end


function on_game_start()
    pr(true, "registering callbacks")
    RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
    RegisterScriptCallback("save_state", save_table)
    RegisterScriptCallback("load_state", load_table)
    RegisterScriptCallback("ActorMenu_on_item_drag_drop", on_item_drag_dropped)
end
