

function pr(debug, ...)
    if debug then
        printf("Repackable Medpacks: %s",...)
    end
end

get_string = game.translate_string

ini_medpack = ini_file_ex("items\\items\\itms_repackable_medpack.ltx")
ini_medical = ini_file_ex("items\\items\\items_medical.ltx")
ini_drugs = ini_file_ex("items\\items\\items_drugs.ltx")
ini_drink = ini_file_ex("items\\items\\items_drink.ltx")
ini_manager = ini_file_ex("items\\settings\\itms_manager.ltx")

bullet_point = get_string("st_medpack_descr_bullet_point")

MEDPACK_TABLE = {}


-- Once a medpack enters the player's inv add to table
-- Store section, id, package contents, capacity, each item weight + medpack weight, max weight threshold
-- if unpacking decrease only package contents
-- if fill add to package contents and for each item added also add it's weight
-- above max weight threshold and medpack slowly starts to decrease in condition (possible update icon in stages)
-- if medpack is open, when zipped, create closed medpack with package contents, remove open medpack
-- if medpack is closed, when unzipped, create open medpack with package contents, remove closed medpack
-- if sold remove from table
-- if dropped and player moves more than 100m from it remove from table
-- if dropped and trans level then remove  
-- id = medpack id
-- section = medpack section name
-- contents = list of medical items
-- capacity = current total amount of items in medpack
-- total_weight = the sum weight of all items in the medpack plus the medpack weight
-- max_weight = total weight limit that the medpack can contain
-- Remove all kits of medpacks and replace all trader profiles with medpack with repackable version

-------------------------------
-- Bools
-------------------------------

function is_vanilla_medpack(obj)
    local v_m_sects = {
        ["medkit_ai1"] = true,
        ["medkit_ai2"] = true,
        ["medkit_ai3"] = true
    }
    return v_m_sects[obj:section()]
end

function is_repackable_medpack(obj)
    local mp_sects = {
        ["medpack_open_basic"] = true,
        ["medpack_open_army"] = true,
        ["medpack_open_sci"] = true,

        ["medpack_closed_basic"] = true,
        ["medpack_closed_army"] = true,
        ["medpack_closed_sci"] = true
    }
    return mp_sects[obj:section()]
end

function is_medpack_compatible(itm_sect)
    if ini_drugs:section_exist(itm_sect) or ini_medical:section_exist(itm_sect) or ini_drink:section_exist(itm_sect) then
        return true
    end
    return false
end

function is_medpack_open(medpack)
    return not get_closed_status(medpack:id())
end

function is_medpack_closed(medpack)
    return get_closed_status(medpack:id())
end

function is_medpack_useable(medpack)
    local condition = medpack:condition()
    if condition > 39 then
        return true
    end
    return false
end

function is_medpack_full(medpack)
    if get_total_itms(medpack:id()) >= get_max_capacity(medpack:id()) then
        return true
    end
    return false
end

function is_medpack_empty(medpack)
    local capacity = get_capacity(medpack:id())
    if capacity > 0 then
        return false
    end
    return true
end

function is_medpack_max_weight(medpack)
    local max_weight = get_max_weight(medpack:id())
    local total_weight = get_total_weight(medpack:id())
    return total_weight < max_weight
end

-------------------------------
-- Tables
-------------------------------

function vanilla_to_repackable(sect, closed)
    local closed_sects = {
        ["medkit_ai1"] = "medpack_closed_basic",
        ["medkit_ai2"] = "medpack_closed_army",
        ["medkit_ai3"] = "medpack_closed_sci"
    }
    local open_sects = {
        ["medkit_ai1"] = "medpack_open_basic",
        ["medkit_ai2"] = "medpack_open_army",
        ["medkit_ai3"] = "medpack_open_sci"
    }
    if closed then
        return closed_sects[sect]
    end
    return open_sects[sect]
end

function open_to_closed_medpack(sect)
    local otc_sects = {
        ["medpack_open_basic"] = "medpack_closed_basic",
        ["medpack_open_army"] = "medpack_closed_army",
        ["medpack_open_sci"] = "medpack_closed_sci",
    }
    return otc_sects[sect]
end

function closed_to_open_medpack(sect)
    local cto_sects = {
        ["medpack_closed_basic"] = "medpack_open_basic",
        ["medpack_closed_army"] = "medpack_open_army",
        ["medpack_closed_sci"] = "medpack_open_sci",
    }
    return cto_sects[sect]
end

function get_colour(name)
    return utils_xml.get_color(name)
end

function get_colour_string(name)
    return strformat("%c[%s]", name)
end

zip_colour = {
    ["zipped"] = get_colour_string("d_green"),
    ["unzipped"] = get_colour_string("d_red")
}

closed_to_zip_status = {
    [true] = "zipped",
    [false] = "unzipped"
}
-------------------------------
-- Track medpacks through table
-------------------------------

function mt_new_entry(medpack)
    local _id = medpack:id()
    if is_medpack_in_table(_id) then return end
    local sect = medpack:section()
    local _contents =  default_contents(sect)
    local ti = #_contents
    local mc = default_max_capacity(sect)
    local bw = ini_medpack:r_value(sect, "inv_weight")
    local tw = calculate_total_weight(_id, _contents, bw)
    local mw = default_max_weight(sect)
    
    MEDPACK_TABLE[#MEDPACK_TABLE + 1] = {id=_id, section=sect, contents=_contents, total_itms=ti, max_capacity=mc, total_weight=tw, max_weight=mw, base_weight=bw, closed=true}
    pr(true, strformat("new entry: id=%s section=%s, contents=%s, total items=%s, max capcity=%s, total weight=%s, max weight=%s, base weight=%s, closed=%s", _id, sect, _contents, ti, mc, tw, mw, bw, true))
end

function get_entry_index(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr(true, strformat("found entry at %s", idx))
            return idx
        end
    end
end

function mt_remove_entry(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr(true, strformat("removing entry at %s", id))
            MEDPACK_TABLE[idx] = nil
        end
    end
end

function mt_replace_entry(old_id, new_id, sect, _contents, _closed)
    local ti = #_contents
    local mc  = default_max_capacity(sect)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(new_id, _contents, bw)
    local mw = default_max_weight(sect)
    local idx = get_entry_index(old_id) or #MEDPACK_TABLE + 1
    pr(true, strformat("replacing entry at %s: id=%s section=%s, contents=%s, total items=%s, max capcity=%s, total weight=%s, max weight=%s, base weight=%s, closed=%s", idx, new_id, sect, _contents, ti, mc, tw, mw, bw, true))
    MEDPACK_TABLE[idx] = {id=new_id, section=sect, contents=_contents, total_itms=ti, max_capacity=mc, total_weight=tw, max_weight=mw, base_weight=bw, closed=_closed}
end

function mt_set_var(id, var, value)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] and entry[var] and type(var) == "string" then
            entry[var] = value
        end
    end
end

function mt_get_var(id, var)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return entry[var]
        end
    end
end

function mt_update_vars(id, tbl)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            for k, v in pairs(entry) do
                if tbl[k] then
                    entry[k] = tbl[k]
                end
            end
        end
    end
end

function mt_all_vars(id, unpck)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            if not unpck then
                return entry
            end
            return unpack(entry)
        end
    end
end

function is_medpack_in_table(id)
    for _, entry in pairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return true
        end
    end
    return false
end

-- Getters and Setters for medpack variables: "contents, capacity, total_weight, max_weight"

-------------------------------
-- Getters
-------------------------------
function get_section(id)
    return mt_get_var(id, "section")
end

function get_contents(id)
    return mt_get_var(id, "contents")
end

function get_max_capacity(id)
    return mt_get_var(id, "max_capacity")
end

function get_total_itms(id)
    return mt_get_var(id, "total_itms")
end

function get_total_weight(id)
    return mt_get_var(id, "total_weight")
end

function get_max_weight(id)
    return mt_get_var(id, "max_weight")
end

function get_base_weight(id)
    return mt_get_var(id, "base_weight")
end

function get_closed_status(id)
    return mt_get_var(id, "closed")
end

-------------------------------
-- Setters
-------------------------------

function set_contents(id, contents)
    mt_set_var(id, "contents", contents)
end

function set_total_itms(id, total_itms)
    mt_set_var(id, "total_itms", total_itms)
end

function set_total_weight(id, total_weight)
    mt_set_var(id, "total_weight", total_weight)
end

-------------------------------
-- Default Medpack vars
-------------------------------

function default_max_capacity(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_value(sect, "max_capcity")
end

function default_max_weight(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_value(sect, "max_weight")
end

function default_contents(sect)
    return parse_list(ini_manager, "package_content", sect)
end

function default_base_weight(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_value(sect, "inv_weight")
end

-------------------------------
-- Common Medpack Functions
-------------------------------
base_use_package = itms_manager.use_package
function itms_manager.use_package(obj)
    base_use_package(obj)
    create_new_medpack(obj, false)
end

base_use_package_random = itms_manager.use_package_random
function itms_manager.use_package_random(obj)
    base_use_package_random(obj)
    create_new_medpack(obj, false)
end

function create_new_medpack(obj, closed)
    if is_vanilla_medpack(obj) then
        local contents = default_contents(obj:section())
        local sect = obj:section()
        local repack_sect = vanilla_to_repackable(obj:section(), closed)
        local medpack = alife_create_item(repack_sect, db.actor)
        alife_release(obj)
        pr(true, strformat("Creating %s , with the contents: %s", repack_sect, table.concat(contents, ", ")))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed)
    end
end

function med_itm_name(sect)
    if ini_drugs:section_exist(sect) then
        return get_string(ini_drugs:r_value(sect, "inv_name"))
    elseif ini_medical:section_exist(sect) then
        return get_string(ini_medical:r_value(sect, "inv_name"))
    elseif ini_drink:section_exist(sect) then
        return get_string(ini_drink:r_value(sect, "inv_name"))
    end  
end

base_obj_desc = ui_item.get_obj_desc
function ui_item.get_obj_desc(obj)
    if is_repackable_medpack(obj) then
        pr(true, strformat("updating description for: %s", obj:section()))
        return medpack_descr(obj, obj:section())
    end
end

function medpack_descr(obj, sect)
    if not is_repackable_medpack(obj) then return end
    local descr = ""
    local default_clr = get_colour_string("default")
    local blue_clr = get_colour_string("d_blue")
    local title_grey_clr = get_colour_string("ui_gray_3")
    local text_grey_clr = get_colour_string("ui_gray_2")
    local cyan_clr = get_colour_string("d_cyan")

    local total_items = get_total_itms(obj:id())
    local contents = get_contents(obj:id())

    local function build_string()
        local base_descr = get_string("st_"..sect.."_base_descr")
        local contents_str = title_grey_clr.."CONTENTS:\\n"
        local props_str = title_grey_clr.."PROPERTIES:\\n"
        local storage_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_storage_descr").."\\n"
        local repack_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_repack_descr").."\\n"
        local closed_status = get_closed_status(obj:id())
        pr(true, strformat("medpack id=%s", obj:id()))
        pr(true, strformat("closed status=%s", closed_status))
        local zip_status = closed_to_zip_status[closed_status]
        local zip_status_str = zip_colour[zip_status].." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_"..zip_status.."_descr").."\\n"
        local end_char = "\\n"

        local items_str = ""
        for i=1, total_items do
            if i == total_items then
                end_char = "\\n \\n"
            end        
            items_str = items_str..strformat("%s %s %s %s %s", cyan_clr, bullet_point, default_clr, med_itm_name(contents[i]), end_char)
        end
        return base_descr..contents_str..items_str..props_str..storage_str..repack_str..zip_status_str
    end
    return build_string()
end    

function update_contents(id, new_contents)
    local contents = get_contents(id)
    for k, v in pairs(new_contents) do
        local cond, value = rpmk_utils.contains(contents, k)
        if cond then
                contents[k] = value + v
        else
            contents[k] = v
        end
    end
    set_contents(id, contents)
    set_capcity(id, #contents)
    set_total_weight(id, calculate_total_weight(id, contents, get_base_weight(id)))
end

function calculate_total_weight(id, contents, base_weight)    
    local total_weight = get_total_weight(id) or (base_weight or 0.15)
    for k, v in pairs(contents) do
        local itm_weight = ini_drugs:r_value(v, "inv_weight") or ini_medical:r_value(v, "inv_weight") or ini_drink:r_value(v, "inv_weight")
        pr(false, strformat("section: %s, itm_weight: %s, total weight: %s", v, itm_weight, total_weight))
        total_weight = total_weight + itm_weight
    end
    return round_idp(total_weight, 2)
end

function get_medpack_type(id)
    local section = get_section(id)
    for _, pattern in pairs({"(medpack_closed_)", "(medpack_open_)"}) do
        if string.match(section, pattern) then
            local start, _end = string.find(section, pattern)
            return string.sub(section, _end + 1, #section)
        end
    end
end

---------------------------------------
-- Functors
---------------------------------------

-- Unpack

function unpack_condition_met(obj)
    if obj and is_medpack_closed(obj) and not is_medpack_empty(obj) then
        return true
    end
    return false
end

function unpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not rpmk_utils.is_repackable_medpack(obj) then return end

    return unpack_condition_met(obj)
end

function unpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unpack")
end

function unpack_action(obj, bag, mode)
    local medpack = obj and rpmk_utils.is_repackable_medpack(obj)
    if not medpack then return end

    rpmk_gui.display_medpack_gui(true, nil, medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_unpack", unpack_condition_function, unpack_menu_function, nil, unpack_action)

-- Fill 

function fill_medpack_condition_met(obj)
    if obj and is_medpack_open(obj) and not is_medpack_full(obj) and not is_medpack_max_weight(obj) then
        return true
    end
    return false
end

function fill_medpack_conditon_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not rpmk_utils.is_repackable_medpack(obj) then return end

    return fill_medpack_condition_met(obj)
end

function fill_medpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_fill")
end

function fill_medpack_action(obj, bag, mode)
    local medpack = obj and rpmk_utils.is_repackable_medpack(obj)
    if not medpack then return end

    rpmk_gui.display_medpack_gui(nil, true, medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_fill", fill_medpack_condition_function, fill_medpack_menu_function, nil, fill_medpack_action)


-- Zip

function zip_condition_met(obj)
    if obj and is_medpack_open(obj) and is_medpack_useable(obj) then
        return true
    end
    return false
end

function zip_conditon_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not rpmk_utils.is_repackable_medpack(obj) then return end

    return zip_condition_met(obj)
end

function zip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_zip")
end

function zip_action(obj, bag, mode)
    local medpack = obj and is_repackable_medpack(obj)
    if not medpack then return end

    local contents = get_contents(medpack:id())
    local closed_sect = open_to_closed_medpack(medpack:sect())
    local obj = alife_create_item(closed_sect, db.actor)
    mt_replace_entry(medpack:id(), obj.id, closed_sect, contents, false)
    alife_release(medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_zip", zip_condition_function, zip_menu_function, nil, zip_action)


-- Unzip

function unzip_condition_met(obj)
    if obj and is_medpack_closed(obj) and is_medpack_useable(obj) then
        return true
    end
    return false
end

function unzip_conditon_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unzip_condition_met(obj)
end

function unzip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unzip")
end

function unzip_action(obj, bag, mode)
    local medpack = obj and rpmk_utils.is_repackable_medpack(obj)
    if not medpack then return end

    local contents = get_contents(medpack:id())
    local open_sect = closed_to_open_medpack(medpack:sect())
    local obj = alife_create_item(open_sect, db.actor)
    mt_replace_entry(medpack:id(), obj.id, open_sect, contents, false)
    alife_release(medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_unzip", unzip_condition_function, unzip_menu_function, nil, unzip_action)


-------------------------------
-- Drag/Drop fill
-------------------------------

function on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
    local p_1, p_2 = obj_1:parent(), obj_2:parent()

    if not ((p_1 and p_1:id() == AC_ID) and (p_2 and p_2:id() == AC_ID)) then
        return
    end

    local itm = obj_1 
    local medpack = obj_2

    if not is_medpack_compatible(itm:section()) or not is_medpack_open(medpack) then return end

    if not drop_condition_met(itm, medpack) then return end

    update_contents(medpack:id(), {itm:section()})
    alife_release(itm)
end

-------------------------------
-- Callbacks
-------------------------------

local function save_table(mdata)
    local SAVE_TABLE = {}
    copy_table(SAVE_TABLE, MEDPACK_TABLE)
    mdata.active_medpacks = SAVE_TABLE
end

local function load_table(mdata)
    local SAVE_TABLE = mdata.active_medpacks or {}
    copy_table(MEDPACK_TABLE, SAVE_TABLE)
end

local function actor_on_item_take(item)
    printf("on take")
    if not is_vanilla_medpack(item) or is_repackable_medpack(item) then return end
    local function search(temp, obj)
        pr(true, strformat("is %s a medpack?", obj:section()))
        if is_vanilla_medpack(obj) or is_repackable_medpack(obj) then
            create_new_medpack(obj, true)
        end
    end

    db.actor:iterate_inventory(search, nil)
end


function on_game_start()
    pr(true, "registering callbacks")
    RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
    RegisterScriptCallback("save_state", save_table)
    RegisterScriptCallback("load_state", load_table)
    RegisterScriptCallback("ActorMenu_on_item_drag_drop", on_item_drag_dropped)
end