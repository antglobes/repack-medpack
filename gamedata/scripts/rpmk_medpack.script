

function pr(debug, ...)
    if debug then
        printf("Repackable Medpacks: %s",...)
    end
end

------------------
-- Imports
------------------

-- Classes
local geometry_ray = demonized_geometry_ray.geometry_ray

-- Functions

get_string = game.translate_string
get_translation = rpmk_utils.get_translation
sum = rpmk_utils.sum
concat_pairs = rpmk_utils.concat_pairs
concat = rpmk_utils.concat
index_of = rpmk_utils.index_of
sum_nested = rpmk_utils.sum_nested
lower = string.lower
collect_section = utils_data.collect_section
trader_type = trader_autoinject.get_trader_type
TraderUpdate = trader_autoinject.update
obj_to_sect_list = rpmk_utils.obj_to_sect_list

-- Configs

ini_medpack = ini_file_ex("items\\items\\items_repackable_medpack.ltx", true)
ini_medical = ini_file_ex("items\\items\\items_medical.ltx")
ini_drugs = ini_file_ex("items\\items\\items_drugs.ltx")
ini_drink = ini_file_ex("items\\items\\items_drink.ltx")
ini_manager = ini_file_ex("items\\settings\\itms_manager.ltx")

-- Other

bullet_point = get_string("st_medpack_descr_bullet_point")
weight_unit = get_string("st_kg")

-- Globals & Constants
MEDPACK_TABLE = {}

function get_colour_string(name)
    return strformat("%c[%s]", name)
end

local default_clr = get_colour_string("default")
local blue_clr = get_colour_string("d_blue")
local title_grey_clr = get_colour_string("ui_gray_3")
local text_grey_clr = get_colour_string("ui_gray_2")
local cyan_clr = get_colour_string("d_cyan")
local orange_clr = get_colour_string("d_orange")
local red_clr = get_colour_string("d_red")
local contents_str = title_grey_clr.."CONTENTS:\\n"
local props_str = title_grey_clr.."PROPERTIES:\\n"
local storage_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_storage_descr").."\\n"
local repack_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_repack_descr").."\\n"
-- Once a medpack enters the player's inv add to table
-- Store section, id, package contents, capacity, each item weight + medpack weight, max weight threshold
-- if unpacking decrease only package contents
-- if repack add to package contents and for each item added also add it's weight
-- above max weight threshold and medpack slowly starts to decrease in condition (possible update icon in stages)
-- if medpack is open, when zipped, create closed medpack with package contents, remove open medpack
-- if medpack is closed, when unzipped, create open medpack with package contents, remove closed medpack
-- if sold remove from table
-- if dropped and player moves more than 100m from it remove from table
-- if dropped and trans level then remove  
-- id = medpack id
-- section = medpack section name
-- contents = list of medical items
-- capacity = current total amount of items in medpack
-- total_weight = the sum weight of all items in the medpack plus the medpack weight
-- max_weight = total weight limit that the medpack can contain
-- Remove all kits of medpacks and replace all trader profiles with medpack with repackable version








-------------------------------
-- Tables
-------------------------------

zip_colour = {
    ["zipped"] = get_colour_string("d_green"),
    ["unzipped"] = get_colour_string("d_red")
}

closed_to_zip_status = {
    [true] = "zipped",
    [false] = "unzipped"
}

sect_to_exclude = {
    ["identity_immunities"] = true,
    ["booster"] = true,
    ["medkit_ai1"] = true,
    ["medkit_ai2"] = true,
    ["medkit_ai3"] = true,
    ["booster_multi"] = true,

}

surfaces = {
    "grass", "earth", "tin", "water", "wood", "metal", "soft", "gravel", "bushes", "default",
    "glass", "concrete", "dirt", "sand", "tree", "clothes", "tile", "asphalt", "furniture"
}

damages = {
    ["grass"] = 0.001,
    ["tin"] = 0.001,
    ["soft"] = 0.001,
    ["clothes"] = 0.001,
    ["metal"] = 0.001,
    ["concrete"] = 0.001,
    ["tile"] = 0.001,
    ["glass"] = 0.001,
    ["tree"] = 0.001,
    ["wood"] = 0.001,
    ["dirt"] = 0.002,
    ["furniture"] = 0.002,
    ["earth"] = 0.0025,
    ["asphalt"] = 0.003,
    ["sand"] = 0.004,
    ["default"] = 0.01,
    ["water"] = 0.015,
    ["bushes"] = 0.02,
    ["gravel"] = 0.02,
}

damage_multi ={
    ["basic"] = 10,
    ["army"] = 6,
    ["sci"] = 2
}

-- If you want to include an item in the medpack, put it's section here
compat_medpack_sects = {
    "bandage_israeli",
    "bio_bandage",
    "medkit_elite",
    "surginst",
    "cms",
    "splint",
    "alu_splint",
    "morphine",
    "adrenalin",
    "propital",
    "zagustin",
    "sj6",
    "etg",
    "analgin",
    "sj1",
}

mp_sects = {
    ["medpack_open_basic"] = true,
    ["medpack_open_army"] = true,
    ["medpack_open_sci"] = true,

    ["medpack_closed_basic"] = true,
    ["medpack_closed_army"] = true,
    ["medpack_closed_sci"] = true
}
-------------------------------
-- Table Functions
-------------------------------

function vanilla_to_repackable(sect, closed)
    local closed_sects = {
        ["medkit_ai1"] = "medpack_closed_basic",
        ["medkit_ai2"] = "medpack_closed_army",
        ["medkit_ai3"] = "medpack_closed_sci"
    }
    local open_sects = {
        ["medkit_ai1"] = "medpack_open_basic",
        ["medkit_ai2"] = "medpack_open_army",
        ["medkit_ai3"] = "medpack_open_sci"
    }
    if closed then
        return closed_sects[sect]
    end
    return open_sects[sect]
end

function switch_status(sect)
    local medpack_sect = {
        ["medpack_closed_basic"] = "medpack_open_basic",
        ["medpack_closed_army"] = "medpack_open_army",
        ["medpack_closed_sci"] = "medpack_open_sci",
        ["medpack_open_basic"] = "medpack_closed_basic",
        ["medpack_open_army"] = "medpack_closed_army",
        ["medpack_open_sci"] = "medpack_closed_sci"
    }
    return medpack_sect[sect]
end

-------------------------------
-- Bools
-------------------------------

function is_vanilla_medpack(obj)
    local v_m_sects = {
        ["medkit_ai1"] = true,
        ["medkit_ai2"] = true,
        ["medkit_ai3"] = true
    }
    return v_m_sects[obj:section()]
end

function is_repackable_medpack(obj)
    return mp_sects[obj:section()]
end

function is_medpack_compatible(itm_sect)
    if ini_drugs:section_exist(itm_sect) or ini_medical:section_exist(itm_sect) or ini_drink:section_exist(itm_sect) or compat_medpack_sects[itm_sect] then
        return true
    end
    return false
end

function is_medpack_open(medpack)
    return not get_closed_status(medpack:id())
end

function is_medpack_closed(medpack)
    return get_closed_status(medpack:id())
end

function is_medpack_useable(medpack)
    local condition = medpack:condition()
    printf("medpack condition: %s:%s", medpack:section(), condition)
    return math.ceil(condition * 100) > 25
end

function is_medpack_zipped(medpack)
    return get_zipped_status(medpack:id())
end


function is_medpack_empty(medpack)
    return get_total_itms(medpack:id()) <= get_base_weight(medpack:id())
end

function is_medpack_full(medpack)
    local tw = get_total_weight(medpack:id())
    local mw = get_max_weight(medpack:id())
    pr(true, strformat("total weight: %s type %s max weight: %s type %s", tw, type(tw),mw, type(mw) ))
    return tw >= mw
end

-------------------------------
-- Track medpacks through table
-------------------------------

function mt_new_entry(medpack)
    local _id = medpack:id()
    if is_medpack_in_table(_id) then return end
    local sect = medpack:section()
    local _contents =  default_contents(sect)
    local ti = sum_nested(_contents)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(_id, sect, _contents, ti, bw)
    local mw = default_max_weight(sect)
    
    MEDPACK_TABLE[#MEDPACK_TABLE + 1] = {id=_id, section=sect, contents=_contents, total_itms=ti, total_weight=tw, max_weight=mw, base_weight=bw, closed=true, zipped=true}
    pr(true, strformat("new entry: id=%s section=%s, contents=%s, total items=%s, total weight=%s, max_weight=%s, base weight=%s, closed=%s, zipped=%s", _id, sect, _contents, ti, tw, mw, bw, true, true))
end

function get_entry_index(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr(true, strformat("found entry at %s", idx))
            return idx
        end
    end
end

function mt_remove_entry(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr(true, strformat("removing entry at %s", id))
            MEDPACK_TABLE[idx] = nil
        end
    end
end

function mt_replace_entry(old_id, new_id, sect, _contents, _closed, _zipped)
    local ti = sum_nested(_contents)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(new_id, sect, _contents, ti, bw)
    local mw = default_max_weight(sect)
    local idx = get_entry_index(old_id) or #MEDPACK_TABLE + 1
    pr(true, strformat("replacing entry at %s: id=%s section=%s, contents=%s, total items=%s, total weight=%s, max weight=%s, base weight=%s, closed=%s, zipped=%s", idx, new_id, sect, _contents, ti, tw, mw, bw, _closed, _zipped))
    MEDPACK_TABLE[idx] = {id=new_id, section=sect, contents=_contents, total_itms=ti, total_weight=tw, max_weight=mw, base_weight=bw, closed=_closed, zipped=_zipped}
end

function mt_set_var(id, var, value)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] and entry[var] and type(var) == "string" then
            entry[var] = value
        end
    end
end

function mt_get_var(id, var)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return entry[var]
        end
    end
end

function mt_update_vars(id, tbl)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            for k, v in pairs(entry) do
                if tbl[k] then
                    entry[k] = tbl[k]
                end
            end
        end
    end
end

function mt_all_vars(id, unpck)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            if not unpck then
                return entry
            end
            return unpack(entry)
        end
    end
end

function is_medpack_in_table(id)
    for _, entry in pairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return true
        end
    end
    return false
end

function has_med_items()
    local med_items = 0
    local function search(temp, obj)
        if is_medpack_compatible(obj:section()) then
            med_items = med_items + 1
        end
    end
    db.actor:iterate_inventory(search, nil)
    return med_items > 0
end

function has_medpacks_in_inv()
    return #get_medpacks() > 0
end

-- Getters and Setters for medpack variables: "contents, capacity, total_weight, max_weight"

-------------------------------
-- Getters
-------------------------------
function get_section(id)
    return mt_get_var(id, "section")
end

function get_contents(id)
    return mt_get_var(id, "contents")
end

function get_total_itms(id)
    return mt_get_var(id, "total_itms")
end

function get_total_weight(id)
    return mt_get_var(id, "total_weight") or 0
end

function get_max_weight(id)
    return mt_get_var(id, "max_weight")
end

function get_base_weight(id)
    return mt_get_var(id, "base_weight")
end

function get_closed_status(id)
    return mt_get_var(id, "closed")
end

function get_zipped_status(id)
    return mt_get_var(id, "zipped")
end

-------------------------------
-- Setters
-------------------------------

function set_contents(id, contents)
    mt_set_var(id, "contents", contents)
end

function set_total_itms(id, total_itms)
    mt_set_var(id, "total_itms", total_itms)
end

function set_total_weight(id, total_weight)
    mt_set_var(id, "total_weight", total_weight)
end

function set_zipped_status(id, zipped)
    mt_set_var(id, "zipped", zipped)
end

function set_conditon(medpack, condition)
    if not is_medpack_in_table(medpack:id()) then return end
    medpack:set_condition(condition)
end

-------------------------------
-- Default Medpack vars
-------------------------------

function default_max_weight(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_float_ex(sect, "max_weight")
end

function default_contents(section)
    pr(true, strformat("Getting contents for: %s", section))
    local contents = {}
    local default_contents = parse_list(ini_manager, "package_content", section)
    for idx, sect in ipairs(default_contents) do
        if contents[sect] then
            table.insert(contents[sect].uses,  get_item_uses(sect))
            contents[sect].amount = contents[sect].amount + 1
        else
            contents[sect] = {uses = {get_item_uses(sect)}, amount = 1}
        end
    end
    return contents
end

function default_base_weight(sect)
    pr(true, strformat("Getting max weight for: %s", sect))
    return ini_medpack:r_float_ex(sect, "inv_weight")
end

-------------------------------
-- Common Medpack Functions
-------------------------------

function create_new_medpack(obj, closed, zipped)
    if is_vanilla_medpack(obj) and not is_medpack_in_table(obj:id()) then
        local contents = default_contents(obj:section())
        local sect = obj:section()
        local repack_sect = vanilla_to_repackable(obj:section(), closed)
        alife():release(alife_object(obj:id()), true)
        local medpack = alife_create_item(repack_sect, db.actor)
        pr(false, strformat("Creating %s , with the contents: %s", repack_sect, concat_pairs(contents)))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed, zipped)
        rax_stacking_control.register(function (x) return x == get_section(medpack.id) end , function(_obj) return false end)
    end
end

function switch_medpack(obj, closed, zipped)
    if is_repackable_medpack(obj) and is_medpack_in_table(obj:id()) then
        local contents = get_contents(obj:id())
        local sect = obj:section()
        local repack_sect = switch_status(sect)
        local medpack = alife_create_item(repack_sect, db.actor, {["cond"]=obj:condition()})
        --alife_release(obj)
        alife():release(alife_object(obj:id()), true)
        pr(false, strformat("Switching medpack from %s to %s, with the contents: %s", sect, repack_sect, concat_pairs(contents)))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed, zipped)
        rax_stacking_control.register(function (x) return x == get_section(medpack.id) end , function(_obj) return false end)
    end
end

-- Medpack Creation & Var building

base_use_package = itms_manager.use_package
function itms_manager.use_package(obj)
    base_use_package(obj)
    create_new_medpack(obj, false, true)
end

base_use_package_random = itms_manager.use_package_random
function itms_manager.use_package_random(obj)
    base_use_package_random(obj)
    create_new_medpack(obj, false, true)
end

function build_contents(sect_list)
    local ordered_contents = {}
    
    for _, sect in ipairs(sect_list) do
        if ordered_contents[sect] then
            ordered_contents[sect].amount = ordered_contents[sect].amount + 1
            table.insert(ordered_contents[sect].uses, get_item_uses(sect))
        else
            ordered_contents[sect] = {uses={get_item_uses(sect)}, amount=1}
        end
    end
    return ordered_contents
end

function get_inv_medpack_itms()
    local items = {}
    local function search(temp, obj)
        pr(false, strformat("Is %s a medpack compatible item?", obj:section()))
        if is_medpack_compatible(obj:section()) and not sect_to_exclude[obj:section()] then
            items[#items + 1] = obj
        end
    end

    db.actor:iterate_inventory(search, nil)
    return items
end

function get_medpacks()
    local medpacks = {}
    local function search(temp, obj)
        if is_repackable_medpack(obj) then
            medpacks[#medpacks + 1] = obj
        end
    end
    db.actor:iterate_inventory(search,nil)
    return medpacks
end

function sum_medpack_weight()
    local medpack_weight = 0
    if not has_medpacks_in_inv() then return medpack_weight end
    for idx, medpack in ipairs(get_medpacks()) do
        local total_weight =  get_total_weight(medpack:id())
        if not total_weight then total_weight = 0 end
        medpack_weight = medpack_weight + total_weight
    end
    return medpack_weight
end

-- Colour Related

function get_colour(name)
    return utils_xml.get_color(name)
end

function get_condition_colour(condition)
    condition = math.floor(condition * 100)
    if condition > 75 then
        return get_colour_string("d_green")
    elseif condition <= 75 and condition >= 50  then
        return get_colour_string("pda_yellow")
    elseif condition < 50 and condition > 25 then
        return get_colour_string("d_orange")
    else
        return get_colour_string("d_red")
    end
end

-- Medpack Description 

base_obj_desc = ui_item.get_obj_desc
function ui_item.get_obj_desc(obj)
    if is_repackable_medpack(obj) then
        pr(false, strformat("updating description for: %s", obj:section()))
        return medpack_descr(obj, obj:section())
    elseif is_vanilla_medpack(obj) then
        return vanilla_medpack_descr(obj, obj:section())
    end
end

local ui_info_item_update = utils_ui.UIInfoItem.Update
function utils_ui.UIInfoItem:Update(obj, sec, flags)
    ui_info_item_update(self, obj, sec, flags)
    if obj and is_repackable_medpack(obj) then
        pr(false, strformat("Writing %s to medpack", get_total_weight(obj:id())))
        self.weight:SetText(get_total_weight(obj:id()).." "..weight_unit)
    end
end

local ui_inv_update_weight = ui_inventory.UIInventory.UpdateWeight
function ui_inventory.UIInventory:UpdateWeight()
    ui_inv_update_weight(self)
    pr(false, "has medpack in inv in order to update")
    if not has_medpacks_in_inv() then return end
    local updated_weight = db.actor:get_total_weight() + sum_medpack_weight() or 0
    pr(true, strformat("Updating weight to %s", updated_weight))
    self.player_weight:SetText(strformat("%s %s", round_idp(updated_weight, 1), weight_unit))
end




function vanilla_medpack_descr(obj, sect)
    local contents = default_contents(sect)
    sect = vanilla_to_repackable(sect)
    local base_descr = get_string("st_"..sect.."_base_descr")        
    local condition_clr = get_condition_colour(obj:condition())
    local max_weight_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." "..get_translation("st_medpack_max_weight_descr", default_max_weight(sect)).." "..weight_unit.."\\n"
    local condition_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." ".."Condition:"..condition_clr.." "..get_translation("st_medpack_condition_descr", math.floor(obj:condition() * 100)).."\\n"
    local zip_status = closed_to_zip_status[true]
    local zip_status_str = zip_colour[zip_status].." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_"..zip_status.."_descr").."\\n"
    local end_char = "\\n"
    local sect_colour = get_string("st_"..sect.."_descr_colour")
    local items_str = ""
    
    
    for item, details in pairs(contents) do
        if index_of(contents, item) == #contents then
            end_char = "\\n \\n"
        end   
       
        local amount_str = strformat("%s x%s", sect_colour, details.amount)         
        items_str = items_str..strformat("%s %s %s %s %s %s", sect_colour, bullet_point, default_clr, med_itm_name(item), amount_str, end_char)
        
       
    end
    if #items_str <= 0 then
        items_str = "\\n"
    end

    return base_descr..contents_str..items_str..props_str..max_weight_str..condition_str..storage_str..repack_str..zip_status_str
end



function medpack_descr(obj, sect)
    if not is_repackable_medpack(obj) then return end
    local descr = ""
    local condition_clr = get_condition_colour(obj:condition())
    local total_items = get_total_itms(obj:id())
    local contents = get_contents(obj:id())

    local function build_string()
        local base_descr = get_string("st_"..sect.."_base_descr")        
        local max_weight_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." "..get_translation("st_medpack_max_weight_descr", get_max_weight(obj:id())).." "..weight_unit.."\\n"
        local condition_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." ".."Condition:"..condition_clr.." "..get_translation("st_medpack_condition_descr", math.floor(obj:condition() * 100)).."\\n"
        local closed_status = get_closed_status(obj:id())
        local zip_status = closed_to_zip_status[closed_status]
        local zip_status_str = zip_colour[zip_status].." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_"..zip_status.."_descr").."\\n"
        local end_char = "\\n"
        local sect_colour = get_string("st_"..sect.."_descr_colour")
        local items_str = ""
        local itr = 1
        for item, details in pairs(contents) do
            if index_of(contents, item) == #contents then
                end_char = "\\n \\n"
            end   
           
            local amount_str = strformat("%s x%s", sect_colour, details.amount)         
            items_str = items_str..strformat("%s %s %s %s %s %s", sect_colour, bullet_point, default_clr, med_itm_name(item), amount_str, end_char)
            
            itr = itr + 1
        end
        if #items_str <= 0 then
            items_str = "\\n"
        end
        return base_descr..contents_str..items_str..props_str..max_weight_str..condition_str..storage_str..repack_str..zip_status_str
    end
    return build_string()
end    

-- Monkey patch UIInfoItem:Update for weight correction


-- Medpack Info

function med_itm_name(sect)
    if ini_drugs:section_exist(sect) then
        return get_string(ini_drugs:r_value(sect, "inv_name"))
    elseif ini_medical:section_exist(sect) then
        return get_string(ini_medical:r_value(sect, "inv_name"))
    elseif ini_drink:section_exist(sect) then
        return get_string(ini_drink:r_value(sect, "inv_name"))
    end  
end

function combine_contents(contents, new_contents)
    for sect, details in pairs(new_contents) do
        printf(#contents)
       
            if contents[sect]  then
                pr(true, strformat("adding %s %s %s to contents", sect, table.concat(contents[sect].uses,","), contents[sect].amount))
                contents[sect].amount = contents[sect].amount + new_contents[sect].amount
                for i=1, #new_contents[sect].uses do
                    table.insert(contents[sect].uses, new_contents[sect].uses[i])
                end
            else
                contents[sect] = {uses=new_contents[sect].uses, amount=new_contents[sect].amount}
                pr(true, strformat("default %s %s %s to contents", sect, table.concat(contents[sect].uses,","), contents[sect].amount))
            end
       
    end
    return contents
end

--fix
function update_contents(id, new_contents)
    local contents = get_contents(id)
    --pr(true, strformat("Updating medpack old contents %s", concat_pairs(contents)))
    --pr(true, strformat("old total items %s, old total weight %s", get_total_itms(id), get_total_weight(id)))
    
    new_contents = combine_contents(contents, new_contents)
   
    
    pr(true, strformat("new contents %s", concat_pairs(new_contents)))
    set_contents(id, new_contents)
    set_total_itms(id, sum_nested(new_contents))
    set_total_weight(id, calculate_total_weight(id, nil, new_contents, get_total_itms(id), get_base_weight(id)))
    pr(true, strformat("new total items %s, new total weight %s", get_total_itms(id), get_total_weight(id)))
end

function get_item_weight(item)
    return ini_drugs:r_float_ex(item, "inv_weight") or ini_medical:r_float_ex(item, "inv_weight") or ini_drink:r_float_ex(item, "inv_weight")
end

function get_item_uses(sect)
    local med_objs = get_inv_medpack_itms()
    for _, obj in pairs(med_objs) do
        pr(false, strformat("%s = %s with %s uses", obj:section(), sect, obj:get_remaining_uses()))
        if obj:section() == sect then
            return obj:get_remaining_uses()
        end
    end
    return ini_drugs:r_float_ex(sect, "max_uses") or ini_medical:r_float_ex(sect, "max_uses") or ini_drink:r_float_ex(sect, "max_uses") or 1
end


function calculate_total_weight(id, sect, contents, total_items, base_weight)
    if not total_items or total_items == 0 then return base_weight end    
    local total_weight = get_total_weight(id) or base_weight
    local medpack_type = get_medpack_type(id, sect)
    pr(true, strformat("total weight: %s", total_weight))
    for item, details in pairs(contents) do
        for i=1, details.amount do
            total_weight = (total_weight + get_item_weight(item)) 
        end
    end

    
    return round_idp(total_weight, 2)
end
  
function get_medpack_type(id, sect)
    local section = get_section(id) or sect
    for _, pattern in pairs({"(medpack_closed_)", "(medpack_open_)"}) do
        if string.match(section, pattern) then
            local start, _end = string.find(section, pattern)
            return string.sub(section, _end + 1, #section)
        end
    end
end

-- Medpack Condition

function update_condition(medpack, result)
    pr(true, strformat("Material %s, Flag %s", result.material_name, result.material_flags))
    if not medpack or not result or not is_medpack_in_table(medpack:id()) then return end
    local surface
    local reduction = 0
    for i=1, #surfaces do
        local start, _end = string.find(result.material_name, surfaces[i])
        if start and _end then
            reduction = damages[surfaces[i]] * damage_multi[get_medpack_type(medpack:id())]
        end
    end
    set_conditon(medpack, medpack:condition() - reduction)
end


base_item_degrade = utils_item.is_degradable
function utils_item.is_degradable(obj, sec)
    if sec and mp_sects[sec] then
        return true
    end
    return base_item_degrade(obj, sec)
end

function drop_rand_itm(id)
    local med_items =  get_inv_medpack_itms()
    local rand_idx = math.random(1,#get_total_itms(id))
    local rand_itm = med_items[rand_idx]
    
    local contents = get_contents(id)
    for item, details in pairs(contents) do
        if item == rand_itm:section() then
            contents[item].amount = contents[item].amount - 1
            if contents[item].amount == 0 then
                contents[item] = nil
            end
            local obj = db.actor:object(rand_itm:section())
            news_manager.relocate_item(db.actor, "out", rand_itm:section())
            db.actor:drop_item(obj)
        end
    end
    update_contents(id, contents)
    return rand_itm:section()
end

function on_medpack_condition_below_threshold()
    for idx, medpack in pairs(get_medpacks()) do 
        if not medpack or not is_medpack_in_table(medpack:id()) then return end
        if not is_medpack_useable(medpack) then
            local item = drop_rand_itm(medpack:id())
            rpmk_utils.display_msg("st_drop_medpack_item", lower(item), get_medpack_type(medpack:id()))
            set_conditon(medpack, medpack:condition() - 0.01)
            tmr = 0
        end
    end
end

-- Monkey-patching UIInventory for trader selling
--- NLTP wg_trade_eur_usd 
base_trader_sell = ui_inventory.UIInventory.TMode_Sell
function ui_inventory.UIInventory.TMode_Sell(self)
    local npc = self:GetPartner()
    printf("trader type %s", trader_type(npc))
    accepted_traders = {
        [3] = true,
        [4] = true
    }
    if not npc or not accepted_traders[trader_type(npc)] then
        printf("normal trade")
        base_trader_sell(self)    
        return
    end

    local cc_sell = self.CC["actor_trade"]
    if (not cc_sell) then
        return
    end
    
    

    for id, _ in pairs(cc_sell.indx_id) do
        local obj = get_object_by_id(id)
        self:On_Item_Exchange(db.actor, npc, obj)
    end

    CreateTimeEvent("medpack_event"..npc:id(), "medpack_removal"..npc:id(), 0.01, function(npc)
        printf("searching %s inv", npc:section())
        local function search(owner, obj)
            if is_repackable_medpack(obj) then
                mt_remove_entry(obj:id())
                alife():release(alife_object(obj:id()), true)
            end
        end
        npc:iterate_inventory(search, npc)
        return true 
    end, npc)  
end





-- Medpack Functionality

function unpack_all(obj)
    if is_medpack_empty(obj) then
        rpmk_utils.display_msg("st_empty_medpack", nil, get_medpack_type(obj:id()))
        return 
    end
    local contents = get_contents(obj:id())
    for item, details in pairs(contents) do
        for i=1, details.amount do
            alife_create_item(item, db.actor, {["uses"]=details.uses[i]})
            rpmk_utils.display_msg("st_unpacked_item", lower(med_itm_name(item)), get_medpack_type(obj:id()))
        end
        contents[index_of(contents, item, true)] = nil
    end
    update_contents(obj:id(), build_contents(contents))
end

function repack_all(obj)
    pr(true, "repacking items")
    local medpack_type = get_medpack_type(obj:id())
    if is_medpack_full(obj) then
        rpmk_utils.display_msg("st_full_medpack", nil, medpack_type)
        return
    elseif not has_med_items() then
        rpmk_utils.display_msg("st_no_meds", nil, medpack_type)
        return
    end

    local total_weight = get_total_weight(obj:id())
    local max_weight = get_max_weight(obj:id())
    local items_to_remove = {}
    local med_items = get_inv_medpack_itms()
    local sect_list = obj_to_sect_list(med_items) --combine_contents(get_contents(obj:id()), build_contents(obj_to_sect_list(med_items)))
    local old_contents = get_contents(obj:id())
    local contents = build_contents(sect_list)

    if #old_contents > 0 then
        contents = combine_contents(old_contents)
    end
    
    pr(true, strformat("Starting Total Weight: %s, Max Weight: %s", total_weight, max_weight))
    
    printf("med item sections")
    for i=1, #med_items do
        for item, details in pairs(contents) do            
            if med_items[i]:section() == item then
                printf("section %s, amount %s, uses %s",med_items[i]:section(), details.amount, table.concat(details.uses, ","))
                local item_weight = get_item_weight(item)
                total_weight = total_weight + item_weight
                pr(true, strformat("New total weight:%s", total_weight))
                
                if total_weight >= max_weight then
                    pr(true, strformat("%s is greater or equal to %s", total_weight, max_weight))
                    details.amount = details.amount - 1
                    table.remove(details.uses, #details.uses)
                    total_weight = total_weight - item_weight
                    if details.amount == 0 then
                        contents[item] = nil
                    end
                elseif total_weight < max_weight then
                    pr(true, strformat("%s is less than %s", total_weight, max_weight))
                    alife():release(alife_object(med_items[i]:id()), true)
                
                end
            end
        end
    end

    --[[
    for item, details in pairs(contents) do
        printf("section %s, amount %s, uses %s", item, details.amount, table.concat(details.uses, ","))
    end
   ]]--



    -- get the weight of each item add to total weight,
    -- if total weight exceeds actual total weight then end loop, 
    -- collect items removed, remove sects from med sects that aren't in items removed
    update_contents(obj:id(), contents)
end



---------------------------------------
-- Custom Functors
---------------------------------------

-- Unpack

function unpack_condition_met(obj)
    if obj and is_medpack_open(obj) or is_medpack_closed(obj) and is_medpack_zipped(obj)  then
        return true
    end
    return false
end

function unpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unpack_condition_met(obj)
end

function unpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unpack")
end

function unpack_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end

    --rpmk_gui.display_medpack_gui(true, nil, medpack)
    unpack_all(obj)
    if is_medpack_closed(medpack) and is_medpack_zipped(medpack) and is_medpack_empty(medpack) then
        switch_medpack(obj, false, false)
    end
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_unpack", unpack_condition_function, unpack_menu_function, nil, unpack_action)

-- Fill 

function repack_medpack_condition_met(obj)
    if obj and is_medpack_open(obj) and not is_medpack_zipped(obj) then
        return true
    end
    return false
end

function repack_medpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return repack_medpack_condition_met(obj)
end

function repack_medpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_repack")
end

function repack_medpack_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end

    --rpmk_gui.display_medpack_gui(nil, true, medpack)
    repack_all(obj)
    --switch_medpack(obj, true)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_repack", repack_medpack_condition_function, repack_medpack_menu_function, nil, repack_medpack_action)


-- Zip

function zip_condition_met(obj)
    if obj and is_medpack_open(obj) and is_medpack_useable(obj) and not is_medpack_zipped(obj) then
        return true
    end
    return false
end

function zip_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return zip_condition_met(obj)
end

function zip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_zip")
end

function zip_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and  obj
    if not medpack then return end
    printf("medpack condition %s", medpack:condition())
    local contents = get_contents(medpack:id())
    local closed_sect = switch_status(medpack:section())
    local obj = alife_create_item(closed_sect, db.actor, {["cond"]=medpack:condition()})
    mt_replace_entry(medpack:id(), obj.id, closed_sect, contents, true, true)
    alife_release(medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_zip", zip_condition_function, zip_menu_function, nil, zip_action)


-- Unzip

function unzip_condition_met(obj)
    if obj and is_medpack_closed(obj) and is_medpack_zipped(obj) then
        return true
    end
    return false
end

function unzip_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unzip_condition_met(obj)
end

function unzip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unzip")
end

function unzip_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end

    local contents = get_contents(medpack:id())
    local open_sect = switch_status(medpack:section())
    local obj = alife_create_item(open_sect, db.actor, {["cond"]=medpack:condition()})
    mt_replace_entry(medpack:id(), obj.id, open_sect, contents, false, false)
    alife_release(medpack)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("rpmk_medpack_unzip", unzip_condition_function, unzip_menu_function, nil, unzip_action)


-------------------------------
-- Drag/Drop repack
-------------------------------

function drop_condition_met(item, medpack)
    local total_weight = get_total_weight(medpack:id())
    local item_weight = get_item_weight(item:section())
    local max_weight = get_max_weight(medpack:id())
    pr(true, strformat("medpack weight at %s, is %s's weight %s over %s", total_weight, item:section(), item_weight, max_weight))
    return item_weight + total_weight < max_weight
    
end

function on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
    pr(true, "on item drag dropped")
    local p_1, p_2 = obj_1:parent(), obj_2:parent()

    if not ((p_1 and p_1:id() == AC_ID) and (p_2 and p_2:id() == AC_ID)) then
        return
    end

    local itm = obj_1 
    local medpack = obj_2

    if not is_medpack_compatible(itm:section()) or not is_medpack_open(medpack) then return end

    if not drop_condition_met(itm, medpack) then
        rpmk_utils.display_msg("st_full_medpack_item", lower(med_itm_name(itm:section())), get_medpack_type(medpack:id()))
        return 
    end
    pr(false, strformat("medpack condition: %s", medpack:condition()))
    update_contents(medpack:id(), build_contents({itm:section()}))
    alife_release(itm)

    --rpmk_utils.display_msg("st_repacked_item", lower(med_itm_name(itm:section())), get_medpack_type(medpack:id()))
end

-------------------------------
-- Callbacks
-------------------------------

local function save_table(mdata)
    local SAVE_TABLE = {}
    copy_table(SAVE_TABLE, MEDPACK_TABLE)
    mdata.active_medpacks = SAVE_TABLE
end

local function load_table(mdata)
    local SAVE_TABLE = mdata.active_medpacks or {}
    copy_table(MEDPACK_TABLE, SAVE_TABLE)
end

local function on_item_take(item)
    pr(true, "on take")
    if is_vanilla_medpack(item) then
        create_new_medpack(item, true, true)
    end
end

local function on_item_drop(obj)
    if not is_repackable_medpack(obj) then return end
    if not actor_menu.last_mode == 0 then return end
    local ray = geometry_ray({ray_range=10,
                        contact_range=5,
                        flags=1 + 2 + 4 + 8, 
                        ignore_object=db.actor})
    local res = ray:get(obj:position(), vector():set(0, -0.999, 0))

    if res.result and res.result.material_name then
        update_condition(obj, res.result)
    end
end

local step = 5000
local tmr = 0
function on_update()
    local tg = time_global()
    if tmr > tg then return end
    tmr = tg + step
    on_medpack_condition_below_threshold()
end

function on_game_start()
    pr(true, "registering callbacks")
    RegisterScriptCallback("actor_on_item_take", on_item_take)
    RegisterScriptCallback("actor_on_item_drop", on_item_drop)
    RegisterScriptCallback("actor_on_update", on_update)
    RegisterScriptCallback("save_state", save_table)
    RegisterScriptCallback("load_state", load_table)
    RegisterScriptCallback("ActorMenu_on_item_drag_drop", on_item_drag_dropped)
end
