--[[    
   Repackable Medpacks
   Author: AntGlobes
   Source: https://www.moddb.com/mods/repackable-medpacks
   Version: v1.0
   Last Modified: 10/12/23
   Purpose: Main Functionality of medpacks, unpack/repack, zip/unzip, var calculation etc
--]]


--- Debugging logger
---@param str string
---@param ... any
function pr(str, ...)
    rpmk_utils.dbg_pr("Repackable Medpacks|Script: %s", str, ...)
end

------------------
-- Imports
------------------

-- Classes
local geometry_ray = demonized_geometry_ray.geometry_ray

-- Functions
--      Base Game
lower = string.lower
get_string = game.translate_string
--      MCM
get_config = rpmk_mcm.get_config
get_config = rpmk_mcm.get_config
--      Utils
get_translation = rpmk_utils.get_translation
sum = rpmk_utils.sum
concat_pairs = rpmk_utils.concat_pairs
concat = rpmk_utils.concat
index_of = rpmk_utils.index_of
sum_nested = rpmk_utils.sum_nested
collect_section = utils_data.collect_section
obj_to_sect_list = rpmk_utils.obj_to_sect_list
mcm_to_itm_clr = rpmk_utils.mcm_to_itm_clr
alt_itm_clr = rpmk_utils.alt_itm_clr
get_colour_string = rpmk_utils.get_colour_string
get_colour = rpmk_utils.get_colour
get_condition_colour = rpmk_utils.get_condition_colour
med_itm_name = rpmk_utils.sect_to_name
get_item_weight = rpmk_utils.get_item_weight
combine_contents = rpmk_utils.combine_contents
is_filter_item = rpmk_utils.is_filter_item
get_filter_num_by_type = rpmk_cosmetics.get_filter_num_by_type

--      Colours
default_clr = rpmk_utils.default_clr
blue_clr =  rpmk_utils.blue_clr
title_grey_clr =  rpmk_utils.title_grey_clr
text_grey_clr =  rpmk_utils.text_grey_clr
cyan_clr =  rpmk_utils.cyan_clr
orange_clr = rpmk_utils.orange_clr
red_clr =  rpmk_utils.red_clr

--      GUI
display_gui = rpmk_gui.display_medpack_gui
--      Trader Auto
trader_type = trader_autoinject.get_trader_type
TraderUpdate = trader_autoinject.update

-- Configs

ini_medpack = rpmk_utils.ini_medpack
ini_medical = rpmk_utils.ini_medical
ini_drugs = rpmk_utils.ini_drugs
ini_drink = rpmk_utils.ini_drink
ini_manager = rpmk_utils.ini_manager
ini_eft_meds = rpmk_utils.ini_eft_meds
config_list = rpmk_utils.config_list

-- Other
bullet_point = get_string("st_medpack_descr_bullet_point")
weight_unit = get_string("st_kg")

-- Globals & Constants
MEDPACK_TABLE = {}
local contents_str = title_grey_clr.."CONTENTS:\\n"
local props_str = title_grey_clr.."PROPERTIES:\\n"
local storage_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_storage_descr").."\\n"
local repack_str = blue_clr.." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_repack_descr").."\\n"

--[[ 
Repackable Medpack Explanation
------------------------------
Once a medpack enters the player's inv add to table
Store section, id, package contents, capacity, each item weight + medpack weight, max weight threshold
if unpacking decrease only package contents
if repack add to package contents and for each item added also add it's weight
above max weight threshold and medpack slowly starts to decrease in condition (possible update icon in stages)
if medpack is open, when zipped, create closed medpack with package contents, remove open medpack
if medpack is closed, when unzipped, create open medpack with package contents, remove closed medpack
if sold remove from table
if dropped and player moves more than 100m from it remove from table
if dropped and trans level then remove  

Medpack Table Variables
-----------------------
id = medpack id
section = medpack section name
contents = list of medical items
capacity = current total amount of items in medpack
total_weight = the sum weight of all items in the medpack plus the medpack weight
max_weight = total weight limit that the medpack can contain
--]]

-------------------------------
-- Tables
-------------------------------

--Mcm conversion tables
mcm_to_clr = {
    ["0"] = "red",
    ["1"] = "blue",
    ["2"] = "yellow",
    ["3"] = "green",
    ["4"] = "orange",
    ["5"] = "purple",
    ["6"] = "grey",
    ["7"] = "black",
    ["8"] = "white"
}

--Returns colour string depending on the zipped status
zip_colour = {
    ["zipped"] = get_colour_string("d_green"),
    ["unzipped"] = get_colour_string("d_red")
}

-- Convert zipped status from bool to string
closed_to_zip_status = {
    [true] = "zipped",
    [false] = "unzipped"
}

sect_to_exclude = rpmk_utils.sect_to_exclude
surfaces = rpmk_utils.surfaces
damages = rpmk_utils.damages

-- Damage multiplier based  on medpack type
damage_multi ={
    ["basic"] = get_config("main", "dam_multi_basic"),
    ["army"] = get_config("main", "dam_multi_army"),
    ["sci"] = get_config("main","dam_multi_basic") 
}

-- Item Weight of each Body Health System Expanded Item
bhs_item_weight = {
    ["bandage_army"] = 0,
    ["surginst"] = 0.15,
    ["cms"] = 0.7,
    ["splint"] = 0.2,
    ["alu_splint"] = 0.4,
    ["morphine"] = 0.07,
    ["adrenalin"] = 0.05,
    ["propital"] = 0.01,
    ["zagustin"] = 0.01,
    ["sj6"] = 0.01,
    ["sj1"] = 0.01,
    ["etg"] = 0.01,
    ["analgin"] = 0.011,
    ["rebirth"] = 0.08,
    ["survival_kit"] = 0.18
}

-- Repackable Medpack sections
mp_sects = {
    ["medpack_open_basic"] = true,
    ["medpack_open_army"] = true,
    ["medpack_open_sci"] = true,

    ["medpack_closed_basic"] = true,
    ["medpack_closed_army"] = true,
    ["medpack_closed_sci"] = true
}
-------------------------------
-- Table Functions
-------------------------------

--- Convert vanilla medpack to repackable medpack section
---@param sect string
---@param closed boolean
function vanilla_to_repackable(sect, closed)
    local closed_sects = {
        ["medkit_ai1"] = "medpack_closed_basic",
        ["medkit_ai2"] = "medpack_closed_army",
        ["medkit_ai3"] = "medpack_closed_sci"
    }
    local open_sects = {
        ["medkit_ai1"] = "medpack_open_basic",
        ["medkit_ai2"] = "medpack_open_army",
        ["medkit_ai3"] = "medpack_open_sci"
    }
    if closed then
        return closed_sects[sect]
    end
    return open_sects[sect]
end

--- Switch zipped status of the medpack
---@param sect string
function switch_status(sect)
    local medpack_sect = {
        ["medpack_closed_basic"] = "medpack_open_basic",
        ["medpack_closed_army"] = "medpack_open_army",
        ["medpack_closed_sci"] = "medpack_open_sci",
        ["medpack_open_basic"] = "medpack_closed_basic",
        ["medpack_open_army"] = "medpack_closed_army",
        ["medpack_open_sci"] = "medpack_closed_sci"
    }
    return medpack_sect[sect]
end

-------------------------------
-- Bools
-------------------------------

--- Check if obj is a vanilla medpack
---@param obj game_object
function is_vanilla_medpack(obj)
    local v_m_sects = {
        ["medkit_ai1"] = true,
        ["medkit_ai2"] = true,
        ["medkit_ai3"] = true
    }
    return v_m_sects[obj:section()]
end

--- Check if obj is repackable medpack
---@param obj game_object
function is_repackable_medpack(obj)
    return mp_sects[obj:section()]
end

--- Check if item section can go into a medpack
---@param itm_sect string
function is_medpack_compatible(itm_sect)
    for _, config in pairs(config_list) do
        if config:section_exist(itm_sect) or bhs_item_weight[itm_sect] then
            return true
        end
    end
    return false
end

--- Alternative check if medpack is unzipped
---@param medpack game_object
function is_medpack_open(medpack)
    return not get_closed_status(medpack:id())
end

--- Alternative check if medpack is zipped
---@param medpack game_object
function is_medpack_closed(medpack)
    return get_closed_status(medpack:id())
end

--- Check if medpack's condition is above set limit
---@param medpack game_object
function is_medpack_useable(medpack)
    local condition = medpack:condition()
    -- printf("medpack condition: %s:%s", medpack:section(), condition)
    return math.ceil(condition * 100) > get_config("main", "cond_limit")
end

--- Check if medpack has zipped status
---@param medpack game_object
function is_medpack_zipped(medpack)
    return get_zipped_status(medpack:id())
end

--- Check if medpack has no contents
---@param medpack game_object
function is_medpack_empty(medpack)
    return get_total_weight(medpack:id()) <= get_base_weight(medpack:id())
end

--- Check if medpack is at max weight/contents is full
---@param medpack game_object
function is_medpack_full(medpack)
    local tw = get_total_weight(medpack:id())
    local mw = get_max_weight(medpack:id())
    pr("total weight: %s type %s max weight: %s type %s", tw, type(tw),mw, type(mw))
    return tw >= mw
end

function is_medpack_has_filters(medpack)
    return #mt_get_var(medpack:id(), "filters") > 0
end

-------------------------------
-- Track medpacks through table
-------------------------------

--- Add new medpack to medpack table
---@param medpack game_object
function mt_new_entry(medpack)
    local _id = medpack:id()
    if is_medpack_in_table(_id) then return end
    local sect = medpack:section()
    local _contents =  default_contents(sect)
    local ti = sum_nested(_contents)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(_id, sect, _contents, ti, bw)
    local mw = default_max_weight(sect)
    local fil = {}
    local mf = get_filter_num_by_type(nil, sect)
    MEDPACK_TABLE[#MEDPACK_TABLE + 1] = {id=_id, section=sect, contents=_contents, total_itms=ti, total_weight=tw, max_weight=mw, base_weight=bw, closed=true, zipped=true, filters=fil, max_filters=mf}
    pr("new entry: id=%s section=%s, contents=%s, total items=%s, total weight=%s, max_weight=%s, base weight=%s, closed=%s, zipped=%s", _id, sect, _contents, ti, tw, mw, bw, true, true)
end

--- Get the index of a medpack table entry
---@param id number
function get_entry_index(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr("found entry at %s", idx)
            return idx
        end
    end
end

--- Removes an entry from the medpack table
---@param id number
function mt_remove_entry(id)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            pr("removing entry at %s", id)
            MEDPACK_TABLE[idx] = nil
        end
    end
end

--- Replace an existing entry with a new entry at the same index
---@param old_id number
---@param new_id number
---@param sect string
---@param _contents table
---@param _closed boolean
---@param _zipped boolean
function mt_replace_entry(old_id, new_id, sect, _contents, _closed, _zipped)
    local ti = sum_nested(_contents)
    local bw = default_base_weight(sect)
    local tw = calculate_total_weight(new_id, sect, _contents, ti, bw)
    local mw = default_max_weight(sect)
    local idx = get_entry_index(old_id) or #MEDPACK_TABLE + 1
    local fil = {}
    local mf = get_filter_num_by_type(nil, sect)
    pr("replacing entry at %s: id=%s section=%s, contents=%s, total items=%s, total weight=%s, max weight=%s, base weight=%s, closed=%s, zipped=%s", idx, new_id, sect, _contents, ti, tw, mw, bw, _closed, _zipped)
    MEDPACK_TABLE[idx] = {id=new_id, section=sect, contents=_contents, total_itms=ti, total_weight=tw, max_weight=mw, base_weight=bw, closed=_closed, zipped=_zipped, filters=fil, max_filters=mf}
end

--- Change an var's value in a certain entry by id
---@param id number
---@param var string
---@param value any
function mt_set_var(id, var, value)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] and entry[var] and type(var) == "string" then
            entry[var] = value
        end
    end
end

--- Get an var's value from a certain entry by id
---@param id number
---@param var any
function mt_get_var(id, var)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return entry[var]
        end
    end
end

--- Change all the contents of an entry, if the ids match
---@param id number
---@param tbl table
function mt_update_vars(id, tbl)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            for k, v in pairs(entry) do
                if tbl[k] then
                    entry[k] = tbl[k]
                end
            end
        end
    end
end

--- Debugging function, returns all vars in an entry
---@param id number
---@param unpck boolean
function mt_all_vars(id, unpck)
    for idx, entry in ipairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            if not unpck then
                return entry
            end
            return unpack(entry)
        end
    end
end

--- Check if the current id already exists in the medpack table
---@param id number
function is_medpack_in_table(id)
    for _, entry in pairs(MEDPACK_TABLE) do
        if id == entry["id"] then
            return true
        end
    end
    return false
end

--- Checks if there are medpack compatible items in the actor's inventory
function has_med_items()
    local med_items = 0
    local function search(temp, obj)
        if is_medpack_compatible(obj:section()) then
            med_items = med_items + 1
        end
    end
    db.actor:iterate_inventory(search, nil)
    return med_items > 0
end

--- Check if repackable medpacks in inv
function has_medpacks_in_inv()
    return #get_medpacks() > 0
end

-------------------------------
-- Getters
-------------------------------

--- Get a Wallet's section
---@param id number
function get_section(id)
    return mt_get_var(id, "section")
end

--- Get a Wallet's contents
---@param id number
function get_contents(id)
    return mt_get_var(id, "contents")
end

--- Get a Wallet's total number of items
---@param id number
function get_total_itms(id)
    return mt_get_var(id, "total_itms")
end

--- Get a Wallet's weight
---@param id number
function get_total_weight(id)
    return mt_get_var(id, "total_weight") or 0
end

--- Get a Wallet's max weight
---@param id number
function get_max_weight(id)
    return mt_get_var(id, "max_weight")
end

--- Get a Wallet's base weight i.e weight of the bag
---@param id number
function get_base_weight(id)
    return mt_get_var(id, "base_weight")
end

--- Get a Wallet's closed status
---@param id number
function get_closed_status(id)
    return mt_get_var(id, "closed")
end

--- Get a Wallet's zipped status
---@param id number
function get_zipped_status(id)
    return mt_get_var(id, "zipped")
end

-------------------------------
-- Setters
-------------------------------

--- Change the contents of a Medpack
---@param id number
---@param contents table
function set_contents(id, contents)
    mt_set_var(id, "contents", contents)
end

--- Change the total number of items for a Medpack
---@param id number
---@param total_itms number
function set_total_itms(id, total_itms)
    mt_set_var(id, "total_itms", total_itms)
end

--- Change total weight of a Medpack
---@param id number
---@param total_weight number
function set_total_weight(id, total_weight)
    mt_set_var(id, "total_weight", total_weight)
end

--- Change zipped status of a Medpack
---@param id number
---@param zipped boolean
function set_zipped_status(id, zipped)
    mt_set_var(id, "zipped", zipped)
end

--- Change the condition of a Medpack
---@param medpack game_object
---@param condition number
function set_conditon(medpack, condition)
    if not is_medpack_in_table(medpack:id()) then return end
    medpack:set_condition(condition)
end

function set_filter(filter_id, medpack)
    local id = medpack:id()
    local filters = mt_get_var(id, "filters")

    if #filters < mt_get_var(id, "max_filters") then
        table.insert(filters, filter_id)
    end
    mt_set_var(medpack:id(), "filters", filters)
end

-------------------------------
-- Default Medpack vars
-------------------------------

--- Get the section defined max weight of a medpack
---@param sect string
function default_max_weight(sect)
    pr("Getting max weight for: %s", sect)
    return ini_medpack:r_float_ex(sect, "max_weight")
end

--- Get the section defined contents of a medpack from "items_manager.ltx"
---@param section string
function default_contents(section)
    pr("Getting contents for: %s", section)
    local default_contents = build_contents(parse_list(ini_manager, "package_content", section))
    pr("Contents of %s: %s", section, default_contents)
    return default_contents
end

--- Get the section defined empty medpack weight
---@param sect string
function default_base_weight(sect)
    pr("Getting max weight for: %s", sect)
    return ini_medpack:r_float_ex(sect, "inv_weight")
end

-------------------------------
-- Common Medpack Functions
-------------------------------

--- Create a new repackable medpack from a vanilla medpack
---@param obj game_object
---@param closed boolean
---@param zipped boolean
function create_new_medpack(obj, closed, zipped)
    if is_vanilla_medpack(obj) and not is_medpack_in_table(obj:id()) then
        local contents = default_contents(obj:section())
        print_table(contents)
        local sect = obj:section()
        local repack_sect = vanilla_to_repackable(obj:section(), closed)
        alife():release(alife_object(obj:id()), true)
        local medpack = alife_create_item(repack_sect, db.actor)
        pr("Creating %s , with the contents: %s", repack_sect, concat_pairs(contents))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed, zipped)
        rax_stacking_control.register(function (x) return x == get_section(medpack.id) end , function(_obj) return false end)
    end
end

--- Create a repackable medpack of the opposite status
---@param obj game_object
---@param closed boolean
---@param zipped boolean
function switch_medpack(obj, closed, zipped)
    if is_repackable_medpack(obj) and is_medpack_in_table(obj:id()) then
        local contents = get_contents(obj:id())
        local sect = obj:section()
        local repack_sect = switch_status(sect)
        local medpack = alife_create_item(repack_sect, db.actor, {["cond"]=obj:condition()})
        --alife_release(obj)
        alife():release(alife_object(obj:id()), true)
        pr("Switching medpack from %s to %s, with the contents: %s", sect, repack_sect, concat_pairs(contents))
        mt_replace_entry(nil, medpack.id, repack_sect, contents, closed, zipped)
        rax_stacking_control.register(function (x) return x == get_section(medpack.id) end , function(_obj) return false end)
    end
end

-- Medpack Creation & Var building

base_use_package = itms_manager.use_package
function itms_manager.use_package(obj)
    base_use_package(obj)
    create_new_medpack(obj, false, true)
end

base_use_package_random = itms_manager.use_package_random
function itms_manager.use_package_random(obj)
    base_use_package_random(obj)
    create_new_medpack(obj, false, true)
end

--- Get a list of objs that are medpack compatible items
function get_inv_medpack_itms()
    local items = {}
    local function search(temp, obj)
        if is_medpack_compatible(obj:section()) and not sect_to_exclude[obj:section()] then
            items[#items + 1] = obj
        end
    end

    db.actor:iterate_inventory(search, nil)
    return items
end

--- Get all medpacks in actor's inventory
function get_medpacks()
    local medpacks = {}
    local function search(temp, obj)
        if is_repackable_medpack(obj) then
            medpacks[#medpacks + 1] = obj
        end
    end
    db.actor:iterate_inventory(search,nil)
    return medpacks
end

--- Get sum of all medpacks total weight
function sum_medpack_weight()
    local medpack_weight = 0
    if not has_medpacks_in_inv() then return medpack_weight end
    for idx, medpack in ipairs(get_medpacks()) do
        local total_weight =  get_total_weight(medpack:id())
        if not total_weight then total_weight = 0 end
        medpack_weight = medpack_weight + total_weight
    end
    return medpack_weight
end

-- Medpack Description 

base_obj_desc = ui_item.get_obj_desc
function ui_item.get_obj_desc(obj)
    if is_repackable_medpack(obj) then
        return medpack_descr(obj, obj:section())
    elseif is_vanilla_medpack(obj) then
        return vanilla_medpack_descr(obj, obj:section())
    end
end

local ui_info_item_update = utils_ui.UIInfoItem.Update
function utils_ui.UIInfoItem:Update(obj, sec, flags)
    ui_info_item_update(self, obj, sec, flags)
    if obj and is_repackable_medpack(obj) then
        self.weight:SetText(round_idp(get_total_weight(obj:id()), 2).." "..weight_unit)
    end
end

local ui_inv_update_weight = ui_inventory.UIInventory.UpdateWeight
function ui_inventory.UIInventory:UpdateWeight()
    ui_inv_update_weight(self)
    if not has_medpacks_in_inv() then return end
    local updated_weight = db.actor:get_total_weight() + sum_medpack_weight() or 0
    self.player_weight:SetText(strformat("%s %s", round_idp(updated_weight, 1), weight_unit))
end



--- Build Custom description for vanilla medpacks
---@param obj game_object
---@param sect string
function vanilla_medpack_descr(obj, sect)
    local contents = default_contents(sect)
    sect = vanilla_to_repackable(sect)
    local base_descr = get_string("st_"..sect.."_base_descr")        
    local condition_clr = get_condition_colour(obj:condition())
    
    local max_weight_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." "..strformat(get_string("st_medpack_max_weight_descr"),default_max_weight(sect)).." "..weight_unit.."\\n"
    local condition_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." ".."Condition:"..condition_clr.." "..strformat(get_string("st_medpack_condition_descr"), math.floor(obj:condition() * 100)).."\\n"
    local zip_status = closed_to_zip_status[true]
    local zip_status_str = zip_colour[zip_status].." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_"..zip_status.."_descr").."\\n"
    local end_char = "\\n"
    local sect_colour = get_string("st_"..sect.."_descr_colour")
    local items_str = ""
    
    local medpack_type = get_medpack_type(nil, sect)
    local itm_clr = mcm_to_itm_clr(get_config("main", "itm_clr_"..medpack_type))
    itm_clr = alt_itm_clr(itm_clr)
    local sect_colour = get_colour_string(itm_clr)

    for item, details in pairs(contents) do
        if item == contents[#contents] then
            end_char = "\\n \\n"
        end   
       
        local amount_str = strformat("%s x%s", sect_colour, details.amount)         
        items_str = items_str..strformat("%s %s %s %s %s %s", sect_colour, bullet_point, default_clr, med_itm_name(item), amount_str, end_char)
        
       
    end
    if #items_str <= 0 then
        items_str = "\\n"
    end

    return base_descr..contents_str..items_str..props_str..max_weight_str..condition_str..storage_str..repack_str..zip_status_str
end


--- Dynamic Description based on medpack type, contents and weight
---@param obj game_object
---@param sect string
function medpack_descr(obj, sect)
    if not is_repackable_medpack(obj) then return end
    local descr = ""
    local condition_clr = get_condition_colour(obj:condition())
    local total_items = get_total_itms(obj:id())
    local contents = get_contents(obj:id())

    local function build_string()
        local base_descr = get_string("st_"..sect.."_base_descr")        
        local max_weight_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." "..get_translation("st_medpack_max_weight_descr", get_max_weight(obj:id())).." "..weight_unit.."\\n"
        local condition_str = orange_clr.." "..bullet_point.." "..text_grey_clr.." ".."Condition:"..condition_clr.." "..get_translation("st_medpack_condition_descr", math.floor(obj:condition() * 100)).."\\n"
        local closed_status = get_closed_status(obj:id())
        local zip_status = closed_to_zip_status[closed_status]
        local zip_status_str = zip_colour[zip_status].." "..bullet_point.." "..text_grey_clr.." "..get_string("st_medpack_"..zip_status.."_descr").."\\n"
        local end_char = "\\n"
        -- printf("itm color basic %s", itm_clr_basic)
        local medpack_type = get_medpack_type(nil, sect)
        local itm_clr = mcm_to_itm_clr(get_config("main", "itm_clr_"..medpack_type))
        itm_clr = alt_itm_clr(itm_clr)
        local sect_colour = get_colour_string(itm_clr) 
        
        --printf("sect %s medpack type %s sect colour %s", sect, medpack_type, sect_colour)

        local items_str = ""
        local itr = 1
        for item, details in pairs(contents) do
            if index_of(contents, item) == #contents then
                end_char = "\\n \\n"
            end   
           
            local amount_str = strformat("%s x%s", sect_colour, details.amount)         
            items_str = items_str..strformat("%s %s %s %s %s %s", sect_colour, bullet_point, default_clr, med_itm_name(item), amount_str, end_char)
            
            itr = itr + 1
        end
        if #items_str <= 0 then
            items_str = "\\n"
        end
        return base_descr..contents_str..items_str..props_str..max_weight_str..condition_str..storage_str..repack_str..zip_status_str
    end
    return build_string()
end    

-- Monkey patch UIInfoItem:Update for weight correction
-- Medpack Info


--- Get the uses of an item by section
---@param sect string
function get_item_uses(sect)
    local med_objs = get_inv_medpack_itms()
    for _, obj in pairs(med_objs) do
        pr("%s = %s with %s uses", obj:section(), sect, obj:get_remaining_uses())
        if obj:section() == sect then
            return obj:get_remaining_uses()
        end
    end
    local uses
    for _, config in pairs(config_list)  do
        uses = config:r_float_ex(sect, "max_uses")
    end
    return uses or 1
end

--- Build a ordered list of contents from a list of sections, holding amount of items and each ones uses
---@param sect_list table
function build_contents(sect_list)
    local ordered_contents = {}
    
    for _, sect in ipairs(sect_list) do
        if ordered_contents[sect] then
            ordered_contents[sect].amount = ordered_contents[sect].amount + 1
            table.insert(ordered_contents[sect].uses, get_item_uses(sect))
        else
            ordered_contents[sect] = {uses={get_item_uses(sect)}, amount=1}
        end
    end
    return ordered_contents
end


--- Update the main medpack vars
---@param id number
---@param new_contents table
function update_contents(id, new_contents)
    local contents = get_contents(id)
    pr("Updating medpack old contents %s", concat_pairs(contents))
    pr("old total items %s, old total weight %s", get_total_itms(id), get_total_weight(id))
    
    new_contents = combine_contents(contents, new_contents)
    pr("new contents %s", concat_pairs(new_contents))
    set_contents(id, new_contents)
    set_total_itms(id, sum_nested(new_contents))
    set_total_weight(id, calculate_total_weight(id, nil, new_contents, get_total_itms(id), get_base_weight(id)))
    pr("new total items %s, new total weight %s", get_total_itms(id), get_total_weight(id))
end

--- Calculate total weight of medpack based on the weight of each item
---@param id number
---@param sect string
---@param contents table
---@param total_items number
---@param base_weight number
function calculate_total_weight(id, sect, contents, total_items, base_weight)
    if not total_items or total_items == 0 then return base_weight end    
    local total_weight = 0 
    local medpack_type = get_medpack_type(id, sect)
    pr("total weight: %s", total_weight)
    for item, details in pairs(contents) do
        for i=1, details.amount do
            total_weight = (total_weight + get_item_weight(item)) 
        end
    end

    return round_idp(total_weight, 2)
end
  
--- Get the type of medpack by section
---@param id number
---@param sect string
function get_medpack_type(id, sect)
    local section = get_section(id) or sect
    for _, pattern in pairs({"(medpack_closed_)", "(medpack_open_)"}) do
        if string.match(section, pattern) then
            local start, _end = string.find(section, pattern)
            return string.sub(section, _end + 1, #section)
        end
    end
end

-- Medpack Condition

--- Change the medpack's condition by on the surface it hit
---@param medpack game_object
---@param result table
function update_condition(medpack, result)
    pr("Material %s, Flag %s", result.material_name, result.material_flags)
    if not medpack or not result or not is_medpack_in_table(medpack:id()) then return end
    local surface
    local reduction = 0
    for i=1, #surfaces do
        local start, _end = string.find(result.material_name, surfaces[i])
        if start and _end then
            reduction = damages[surfaces[i]] * damage_multi[get_medpack_type(medpack:id())]
        end
    end
    set_conditon(medpack, medpack:condition() - reduction)
end


base_item_degrade = utils_item.is_degradable
function utils_item.is_degradable(obj, sec)
    if sec and mp_sects[sec] then
        return true
    end
    return base_item_degrade(obj, sec)
end

--- Drop a random item from the medpacks contents
---@param id number
function drop_rand_itm(id)
    local med_items =  get_inv_medpack_itms()
    local rand_idx = math.random(1,#get_total_itms(id))
    local rand_itm = med_items[rand_idx]
    
    local contents = get_contents(id)
    for item, details in pairs(contents) do
        if item == rand_itm:section() then
            contents[item].amount = contents[item].amount - 1
            if contents[item].amount == 0 then
                contents[item] = nil
            end
            local obj = db.actor:object(rand_itm:section())
            news_manager.relocate_item(db.actor, "out", rand_itm:section())
            db.actor:drop_item(obj)
        end
    end
    update_contents(id, contents)
    return rand_itm:section()
end

--- Time based check to see if any medpack is below the medpack threshold
function on_medpack_condition_below_threshold()
    --[[
    for idx, medpack in pairs(get_medpacks()) do 
        if not medpack or not is_medpack_in_table(medpack:id()) then return end
        if not is_medpack_useable(medpack) then
            local item = drop_rand_itm(medpack:id())
            rpmk_utils.display_msg("st_drop_medpack_item", lower(item), get_medpack_type(medpack:id()))
            set_conditon(medpack, medpack:condition() - 0.01)
            tmr = 0
        end
    end]]--
end

-- Monkey-patching UIInventory for trader selling
---@author:NLTP-ashes 

base_trader_sell = ui_inventory.UIInventory.TMode_Sell
function ui_inventory.UIInventory.TMode_Sell(self)
    local npc = self:GetPartner()
    -- printf("trader type %s", trader_type(npc))
    accepted_traders = {
        [3] = true,
        [4] = true
    }
    if not npc or not accepted_traders[trader_type(npc)] then
        -- printf("normal trade")
        base_trader_sell(self)    
        return
    end

    local cc_sell = self.CC["actor_trade"]
    if (not cc_sell) then
        return
    end
    
    

    for id, _ in pairs(cc_sell.indx_id) do
        local obj = get_object_by_id(id)
        self:On_Item_Exchange(db.actor, npc, obj)
    end

    CreateTimeEvent("medpack_event"..npc:id(), "medpack_removal"..npc:id(), 0.01, function(npc)
        -- printf("searching %s inv", npc:section())
        local function search(owner, obj)
            if is_repackable_medpack(obj) then
                mt_remove_entry(obj:id())
                alife():release(alife_object(obj:id()), true)
            end
        end
        npc:iterate_inventory(search, npc)
        return true 
    end, npc)  
end





-- Medpack Functionality

--- Remove all items from the medpack into the actor's inventory
---@param obj game_object
function unpack_all(obj)
    if is_medpack_empty(obj) then
        rpmk_utils.display_msg("st_empty_medpack", nil, get_medpack_type(obj:id()))
        return 
    end
    local contents = get_contents(obj:id())
    for item, details in pairs(contents) do
        for i=1, details.amount do
            alife_create_item(item, db.actor, {["uses"]=details.uses[i]})
            rpmk_utils.display_msg("st_unpacked_item", lower(med_itm_name(item)), get_medpack_type(obj:id()))
        end
        contents[index_of(contents, item, true)] = nil
    end
    update_contents(obj:id(), build_contents(contents))
end

--- Move all items under the max weight of a medpack into the specified medpack from actor inventory
---@param obj game_object
function repack_all(obj)
    pr("repacking items")
    local medpack_type = get_medpack_type(obj:id())
    if is_medpack_full(obj) then
        rpmk_utils.display_msg("st_full_medpack", nil, medpack_type)
        return
    elseif not has_med_items() then
        rpmk_utils.display_msg("st_no_meds", nil, medpack_type)
        return
    end

    local total_weight = get_total_weight(obj:id())
    local max_weight = get_max_weight(obj:id())
    local items_to_remove = {}
    local med_items = get_inv_medpack_itms()
    local sect_list = obj_to_sect_list(med_items) 
    local old_contents = get_contents(obj:id())
    local contents = build_contents(sect_list)

    if #old_contents > 0 then
        contents = combine_contents(old_contents)
    end
    
    pr("Starting Total Weight: %s, Max Weight: %s", total_weight, max_weight)
    
    -- printf("med item sections")
    for i=1, #med_items do
        for item, details in pairs(contents) do            
            if med_items[i]:section() == item then
                -- printf("section %s, amount %s, uses %s",med_items[i]:section(), details.amount, table.concat(details.uses, ","))
                local item_weight = get_item_weight(item)
                total_weight = total_weight + item_weight
                pr("New total weight:%s", total_weight)
                
                if total_weight >= max_weight then
                    pr("%s is greater or equal to %s", total_weight, max_weight)
                    details.amount = details.amount - 1
                    table.remove(details.uses, #details.uses)
                    total_weight = total_weight - item_weight
                    if details.amount == 0 then
                        contents[item] = nil
                    end
                elseif total_weight < max_weight then
                    pr("%s is less than %s", total_weight, max_weight)
                    alife():release(alife_object(med_items[i]:id()), true)
                
                end
            end
        end
    end

    -- get the weight of each item add to total weight,
    -- if total weight exceeds actual total weight then end loop, 
    -- collect items removed, remove sects from med sects that aren't in items removed
    update_contents(obj:id(), contents)
end



---------------------------------------
-- Custom Functors
---------------------------------------
local add_functor = custom_functor_autoinject.add_functor
-- Unpack

function unpack_condition_met(obj)
    if obj and is_medpack_open(obj) or is_medpack_closed(obj) and is_medpack_zipped(obj)  then
        return true
    end
    return false
end

function unpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unpack_condition_met(obj)
end

function unpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unpack")
end

function unpack_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end

    unpack_all(obj)
    if is_medpack_closed(medpack) and is_medpack_zipped(medpack) and is_medpack_empty(medpack) then
        switch_medpack(obj, false, false)
    end
end

add_functor("rpmk_medpack_unpack", unpack_condition_function, unpack_menu_function, nil, unpack_action)

-- Fill 

function repack_medpack_condition_met(obj)
    if obj and is_medpack_open(obj) and not is_medpack_zipped(obj) then
        return true
    end
    return false
end

function repack_medpack_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return repack_medpack_condition_met(obj)
end

function repack_medpack_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_repack")
end

function repack_medpack_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end

    repack_all(obj)
end

add_functor("rpmk_medpack_repack", repack_medpack_condition_function, repack_medpack_menu_function, nil, repack_medpack_action)


-- Zip

function zip_condition_met(obj)
    if obj and is_medpack_open(obj) and is_medpack_useable(obj) and not is_medpack_zipped(obj) then
        return true
    end
    return false
end

function zip_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return zip_condition_met(obj)
end

function zip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_zip")
end

function zip_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and  obj
    if not medpack then return end
    local contents = get_contents(medpack:id())
    local closed_sect = switch_status(medpack:section())
    local obj = alife_create_item(closed_sect, db.actor, {["cond"]=medpack:condition()})
    mt_replace_entry(medpack:id(), obj.id, closed_sect, contents, true, true)
    alife_release(medpack)
end

add_functor("rpmk_medpack_zip", zip_condition_function, zip_menu_function, nil, zip_action)


-- Unzip

function unzip_condition_met(obj)
    if obj and is_medpack_closed(obj) and is_medpack_zipped(obj) then
        return true
    end
    return false
end

function unzip_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return unzip_condition_met(obj)
end

function unzip_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_unzip")
end

function unzip_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end

    local contents = get_contents(medpack:id())
    local open_sect = switch_status(medpack:section())
    local obj = alife_create_item(open_sect, db.actor, {["cond"]=medpack:condition()})
    mt_replace_entry(medpack:id(), obj.id, open_sect, contents, false, false)
    alife_release(medpack)
end

add_functor("rpmk_medpack_unzip", unzip_condition_function, unzip_menu_function, nil, unzip_action)

-- open

function open_condition_met(obj)
    if obj and get_config("main","enable_gui") and is_medpack_useable(obj) and not is_medpack_zipped(obj) then
        return true
    end
    return false
end

function open_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return open_condition_met(obj)
end

function open_menu_function(obj, bag, mode)
    return get_string("st_rpmk_menu_open")
end

function open_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end
    pr("loading UI")
    rpmk_gui.display_medpack_gui(medpack)
end

add_functor("rpmk_medpack_open", open_condition_function, open_menu_function, nil, open_action)

-- Remove filter

function remove_filter_condition_met(obj)
    if obj and is_medpack_useable(obj) and is_medpack_has_filters(obj) and not is_medpack_zipped(obj) then
        return true
    end
    return false
end

function remove_filter_condition_function(obj, bag, mode)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    if not is_repackable_medpack(obj) then return end

    return open_condition_met(obj)
end

function remove_filter_menu_function(obj, bag, mode)
    local filters = mt_get_var(obj:id(), "filters")
    local filter_sect = rpmk_cosmetics.pwt_get_var(filters[1], "section")
    return get_translation("st_rpmk_menu_remove_filter", med_itm_name(filter_sect))
end

function remove_filter_action(obj, bag, mode)
    local medpack = is_repackable_medpack(obj) and obj
    if not medpack then return end
    
    local filters = mt_get_var(obj:id(), "filters")
    local filter_sect = rpmk_cosmetics.pwt_get_var(filters[1], "section")
    table.remove(filters, 1)
    mt_set_var(obj:id(), "filters", filters)
    alife_create_item(filter_sect, db.actor)
end

add_functor("rpmk_medpack_remove_filter", remove_filter_condition_function, remove_filter_menu_function, nil, remove_filter_action)


-------------------------------
-- Drag/Drop repack
-------------------------------

function drop_condition_met(item, medpack)
    local total_weight = get_total_weight(medpack:id())
    local item_weight = get_item_weight(item:section())
    local max_weight = get_max_weight(medpack:id())
    pr("medpack weight at %s, is %s's weight %s over %s", total_weight, item:section(), item_weight, max_weight)
    return item_weight + total_weight < max_weight
    
end

function on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
    pr("on item drag dropped")
    local p_1, p_2 = obj_1:parent(), obj_2:parent()

    if not ((p_1 and p_1:id() == AC_ID) and (p_2 and p_2:id() == AC_ID)) then
        return
    end

    local itm = obj_1 
    local medpack = obj_2

    if rpmk_cosmetics.is_filter_item(itm:section()) and is_medpack_open(medpack) then
        set_filter(itm:id())
        rpmk_cosmetics.pwt_new_entry(medpack:id(), itm)
        alife_release(itm)
        return
    end

    if not is_medpack_compatible(itm:section()) or not is_medpack_open(medpack) or rpmk_cosmetics.is_filter_item(itm:section()) then return end

    if not drop_condition_met(itm, medpack) then
        rpmk_utils.display_msg("st_full_medpack_item", lower(med_itm_name(itm:section())), get_medpack_type(medpack:id()))
        return 
    end
    pr("medpack condition: %s", medpack:condition())
    

    set_contents(combine_contents(get_contents(medpack:id()),  build_contents({itm:section()})))
    set_total_itms(get_total_itms(medpack:id() + 1))
    set_total_weight(medpack:id(), get_total_weight(medpack:id()) + get_item_weight(itm:section()))

    alife_release(itm)
end

-------------------------------
-- Callbacks
-------------------------------

local function save_table(mdata)
    local SAVE_TABLE = {}
    copy_table(SAVE_TABLE, MEDPACK_TABLE)
    mdata.active_medpacks = SAVE_TABLE
end

local function load_table(mdata)
    local SAVE_TABLE = mdata.active_medpacks or {}
    copy_table(MEDPACK_TABLE, SAVE_TABLE)
end

local function on_item_take(item)
    if is_vanilla_medpack(item) then
        create_new_medpack(item, true, true)
    end
end

local function on_item_drop(obj)
    if not is_repackable_medpack(obj) then return end
    if not actor_menu.last_mode == 0 then return end
    local ray = geometry_ray({ray_range=10,
                        contact_range=5,
                        flags=1 + 2 + 4 + 8, 
                        ignore_object=db.actor})
    local res = ray:get(obj:position(), vector():set(0, -0.999, 0))

    if res.result and res.result.material_name then
        update_condition(obj, res.result)
    end
end

local step = 5000
local tmr = 0
function on_update()
    local tg = time_global()
    if tmr > tg then return end
    tmr = tg + step
    on_medpack_condition_below_threshold()
end

function on_game_start()
    pr("registering callbacks")
    RegisterScriptCallback("actor_on_item_take", on_item_take)
    RegisterScriptCallback("actor_on_item_drop", on_item_drop)
    RegisterScriptCallback("actor_on_update", on_update)
    RegisterScriptCallback("save_state", save_table)
    RegisterScriptCallback("load_state", load_table)
    RegisterScriptCallback("ActorMenu_on_item_drag_drop", on_item_drag_dropped)
end
